{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"mcp-ephemeral-k8s","text":"<p>Python implementation to spawn ephemeral Model Context Protocol (MCP) servers using the kubernetes API.</p>"},{"location":"modules/","title":"Modules","text":"<p>This module contains the session manager for the MCP ephemeral K8s library. It is used to create and manage MCP servers in a Kubernetes cluster.</p> <p>MCP server application, meant to be used as an MCP server that can spawn other MCP servers.</p> <p>FastAPI application for the MCP ephemeral server.</p> <p>This module contains the models for the MCP ephemeral K8s library.</p> <p>This module contains the exceptions for the MCP ephemeral K8s library.</p> <p>This module contains a utility function to generate unique identifiers for MCP ephemeral K8s resources based on RFC 1123 Label Names.</p>"},{"location":"modules/#mcp_ephemeral_k8s.session_manager.KubernetesSessionManager","title":"<code>KubernetesSessionManager</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Kubernetes session manager for MCP.</p> <p>This manager creates and manages Kubernetes jobs for MCP sessions. It implements the async context manager protocol for easy resource management.</p> Source code in <code>src/mcp_ephemeral_k8s/session_manager.py</code> <pre><code>class KubernetesSessionManager(BaseModel):\n    \"\"\"\n    Kubernetes session manager for MCP.\n\n    This manager creates and manages Kubernetes jobs for MCP sessions.\n    It implements the async context manager protocol for easy resource management.\n    \"\"\"\n\n    model_config = ConfigDict(arbitrary_types_allowed=True)\n\n    namespace: str = Field(default=\"default\", description=\"The namespace to create resources in\")\n    jobs: dict[str, EphemeralMcpServer] = Field(\n        default_factory=dict,\n        description=\"A dictionary mapping between pod names and MCP servers jobs that are running.\",\n    )\n    runtime: KubernetesRuntime = Field(\n        default=KubernetesRuntime.KUBECONFIG, description=\"The runtime to use for the MCP server\"\n    )\n    sleep_time: float = Field(default=1, description=\"The time to sleep between job status checks\")\n    max_wait_time: float = Field(default=300, description=\"The maximum time to wait for a job to complete\")\n    _api_client: ApiClient = PrivateAttr()\n    _batch_v1: BatchV1Api = PrivateAttr()\n    _core_v1: CoreV1Api = PrivateAttr()\n\n    def load_session_manager(self) -&gt; Self:\n        \"\"\"Load Kubernetes configuration from default location or from service account if running in cluster.\"\"\"\n        self._load_kube_config()\n        if not hasattr(self, \"_api_client\"):\n            self._api_client = ApiClient()\n        if not hasattr(self, \"_batch_v1\"):\n            self._batch_v1 = BatchV1Api(self._api_client)\n        if not hasattr(self, \"_core_v1\"):\n            self._core_v1 = CoreV1Api(self._api_client)\n        # check if the configured namespace exists\n        namespaces = self._core_v1.list_namespace().items\n        if self.namespace not in [namespace.metadata.name for namespace in namespaces if namespace.metadata]:\n            raise MCPNamespaceNotFoundError(self.namespace)\n        return self\n\n    def _load_kube_config(self) -&gt; None:\n        \"\"\"Load Kubernetes configuration from default location or from service account if running in cluster.\"\"\"\n        if self.runtime == KubernetesRuntime.KUBECONFIG:\n            try:\n                load_kube_config(\n                    config_file=os.environ.get(\"KUBECONFIG\"),\n                    context=os.environ.get(\"KUBECONTEXT\"),\n                    client_configuration=None,\n                    persist_config=False,\n                )\n                logger.info(\"Using local kubernetes configuration\")\n                return  # noqa: TRY300\n            except Exception:\n                logger.warning(\"Failed to load local kubernetes configuration, trying in-cluster configuration\")\n                self.runtime = KubernetesRuntime.INCLUSTER\n        if self.runtime == KubernetesRuntime.INCLUSTER:\n            load_incluster_config()\n            logger.info(\"Using in-cluster kubernetes configuration\")\n            return\n        raise InvalidKubeConfigError(self.runtime)\n\n    def __enter__(self) -&gt; Self:\n        \"\"\"Enter the context manager.\"\"\"\n        self.load_session_manager()\n        return self\n\n    def __exit__(self, exc_type: Any, exc_val: Any, exc_tb: Any) -&gt; None:\n        \"\"\"Exit the context manager.\"\"\"\n        for job_name in self.jobs:\n            self._delete_job(job_name)\n\n    def _create_job(self, config: EphemeralMcpServerConfig) -&gt; EphemeralMcpServer:\n        \"\"\"\n        Create a job that will run until explicitly terminated.\n\n        Args:\n            config: The configuration for the MCP servers\n\n        Returns:\n            The MCP server instance\n        \"\"\"\n        job = create_mcp_server_job(config, self.namespace)\n        response = self._batch_v1.create_namespaced_job(namespace=self.namespace, body=job)\n        logger.info(f\"Job '{config.job_name}' created successfully\")\n        logger.debug(f\"Job response: {response}\")\n        if not response.metadata or not response.metadata.name:\n            raise MCPServerCreationError(str(response.metadata))\n        return EphemeralMcpServer(config=config, pod_name=response.metadata.name)\n\n    def _get_job_status(self, pod_name: str) -&gt; None | client.V1Job:\n        \"\"\"\n        Get current status of a job.\n\n        Args:\n            pod_name: Name of the pod\n\n        Returns:\n            The job status\n        \"\"\"\n        return get_mcp_server_job_status(self._batch_v1, pod_name, self.namespace)\n\n    def _check_pod_status(self, pod_name: str) -&gt; bool:\n        \"\"\"\n        Check the status of pods associated with a job.\n\n        Args:\n            pod_name: Name of the job/pod\n\n        Returns:\n            True if a pod is running and ready (probes successful), False if waiting for pods\n\n        Raises:\n            MCPJobError: If a pod is in Failed or Unknown state\n        \"\"\"\n        return check_pod_status(self._core_v1, pod_name, self.namespace)\n\n    def _wait_for_job_ready(self, pod_name: str) -&gt; None:\n        \"\"\"Wait for a job's pod to be in the running state and ready (probes successful).\n\n        Args:\n            pod_name: Name of the job/pod\n        \"\"\"\n        wait_for_job_ready(self._batch_v1, self._core_v1, pod_name, self.namespace, self.sleep_time, self.max_wait_time)\n\n    def _wait_for_job_deletion(self, pod_name: str) -&gt; None:\n        \"\"\"Wait for a job to be deleted.\n\n        Args:\n            pod_name: Name of the job/pod\n        \"\"\"\n        wait_for_job_deletion(self._batch_v1, pod_name, self.namespace, self.sleep_time, self.max_wait_time)\n\n    def _delete_job(self, pod_name: str) -&gt; bool:\n        \"\"\"\n        Delete a Kubernetes job and its associated pods.\n\n        Args:\n            pod_name: Name of the job/pod\n\n        Returns:\n            True if the job was deleted successfully, False otherwise\n        \"\"\"\n        try:\n            self.remove_mcp_server_port(self.jobs[pod_name])\n        except Exception:\n            logger.warning(f\"Failed to remove MCP server port for job {pod_name}\")\n        return delete_mcp_server_job(self._core_v1, self._batch_v1, pod_name, self.namespace)\n\n    def create_mcp_server(\n        self, config: EphemeralMcpServerConfig, wait_for_ready: bool = True, expose_port: bool = False\n    ) -&gt; EphemeralMcpServer:\n        \"\"\"Start a new MCP server using the provided configuration.\n\n        Args:\n            config: The configuration for the MCP servers\n            wait_for_ready: Whether to wait for the job to be ready\n\n        Returns:\n            The MCP server instance\n        \"\"\"\n        mcp_server = self._create_job(config)\n        self.jobs[mcp_server.pod_name] = mcp_server\n        if wait_for_ready:\n            self._wait_for_job_ready(mcp_server.pod_name)\n        if expose_port:\n            self.expose_mcp_server_port(mcp_server)\n        return mcp_server\n\n    def delete_mcp_server(self, pod_name: str, wait_for_deletion: bool = True) -&gt; EphemeralMcpServer:\n        \"\"\"Delete the MCP server.\n\n        Args:\n            pod_name: Name of the job/pod\n            wait_for_deletion: Whether to wait for the job to be deleted\n\n        Returns:\n            The MCP server instance\n        \"\"\"\n        if pod_name in self.jobs:\n            self._delete_job(pod_name)\n            if wait_for_deletion:\n                self._wait_for_job_deletion(pod_name)\n            config = self.jobs[pod_name].config\n            result = EphemeralMcpServer(config=config, pod_name=pod_name)\n            del self.jobs[pod_name]\n            return result\n        raise MCPJobNotFoundError(self.namespace, pod_name)\n\n    def expose_mcp_server_port(self, mcp_server: EphemeralMcpServer) -&gt; None:\n        \"\"\"Expose the MCP server port to the outside world.\"\"\"\n        expose_mcp_server_port(self._core_v1, mcp_server.pod_name, self.namespace, mcp_server.config.port)\n\n    def remove_mcp_server_port(self, mcp_server: EphemeralMcpServer) -&gt; None:\n        \"\"\"Remove the MCP server port from the outside world.\"\"\"\n        remove_mcp_server_port(self._core_v1, mcp_server.pod_name, self.namespace)\n</code></pre>"},{"location":"modules/#mcp_ephemeral_k8s.session_manager.KubernetesSessionManager.__enter__","title":"<code>__enter__()</code>","text":"<p>Enter the context manager.</p> Source code in <code>src/mcp_ephemeral_k8s/session_manager.py</code> <pre><code>def __enter__(self) -&gt; Self:\n    \"\"\"Enter the context manager.\"\"\"\n    self.load_session_manager()\n    return self\n</code></pre>"},{"location":"modules/#mcp_ephemeral_k8s.session_manager.KubernetesSessionManager.__exit__","title":"<code>__exit__(exc_type, exc_val, exc_tb)</code>","text":"<p>Exit the context manager.</p> Source code in <code>src/mcp_ephemeral_k8s/session_manager.py</code> <pre><code>def __exit__(self, exc_type: Any, exc_val: Any, exc_tb: Any) -&gt; None:\n    \"\"\"Exit the context manager.\"\"\"\n    for job_name in self.jobs:\n        self._delete_job(job_name)\n</code></pre>"},{"location":"modules/#mcp_ephemeral_k8s.session_manager.KubernetesSessionManager.create_mcp_server","title":"<code>create_mcp_server(config, wait_for_ready=True, expose_port=False)</code>","text":"<p>Start a new MCP server using the provided configuration.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>EphemeralMcpServerConfig</code> <p>The configuration for the MCP servers</p> required <code>wait_for_ready</code> <code>bool</code> <p>Whether to wait for the job to be ready</p> <code>True</code> <p>Returns:</p> Type Description <code>EphemeralMcpServer</code> <p>The MCP server instance</p> Source code in <code>src/mcp_ephemeral_k8s/session_manager.py</code> <pre><code>def create_mcp_server(\n    self, config: EphemeralMcpServerConfig, wait_for_ready: bool = True, expose_port: bool = False\n) -&gt; EphemeralMcpServer:\n    \"\"\"Start a new MCP server using the provided configuration.\n\n    Args:\n        config: The configuration for the MCP servers\n        wait_for_ready: Whether to wait for the job to be ready\n\n    Returns:\n        The MCP server instance\n    \"\"\"\n    mcp_server = self._create_job(config)\n    self.jobs[mcp_server.pod_name] = mcp_server\n    if wait_for_ready:\n        self._wait_for_job_ready(mcp_server.pod_name)\n    if expose_port:\n        self.expose_mcp_server_port(mcp_server)\n    return mcp_server\n</code></pre>"},{"location":"modules/#mcp_ephemeral_k8s.session_manager.KubernetesSessionManager.delete_mcp_server","title":"<code>delete_mcp_server(pod_name, wait_for_deletion=True)</code>","text":"<p>Delete the MCP server.</p> <p>Parameters:</p> Name Type Description Default <code>pod_name</code> <code>str</code> <p>Name of the job/pod</p> required <code>wait_for_deletion</code> <code>bool</code> <p>Whether to wait for the job to be deleted</p> <code>True</code> <p>Returns:</p> Type Description <code>EphemeralMcpServer</code> <p>The MCP server instance</p> Source code in <code>src/mcp_ephemeral_k8s/session_manager.py</code> <pre><code>def delete_mcp_server(self, pod_name: str, wait_for_deletion: bool = True) -&gt; EphemeralMcpServer:\n    \"\"\"Delete the MCP server.\n\n    Args:\n        pod_name: Name of the job/pod\n        wait_for_deletion: Whether to wait for the job to be deleted\n\n    Returns:\n        The MCP server instance\n    \"\"\"\n    if pod_name in self.jobs:\n        self._delete_job(pod_name)\n        if wait_for_deletion:\n            self._wait_for_job_deletion(pod_name)\n        config = self.jobs[pod_name].config\n        result = EphemeralMcpServer(config=config, pod_name=pod_name)\n        del self.jobs[pod_name]\n        return result\n    raise MCPJobNotFoundError(self.namespace, pod_name)\n</code></pre>"},{"location":"modules/#mcp_ephemeral_k8s.session_manager.KubernetesSessionManager.expose_mcp_server_port","title":"<code>expose_mcp_server_port(mcp_server)</code>","text":"<p>Expose the MCP server port to the outside world.</p> Source code in <code>src/mcp_ephemeral_k8s/session_manager.py</code> <pre><code>def expose_mcp_server_port(self, mcp_server: EphemeralMcpServer) -&gt; None:\n    \"\"\"Expose the MCP server port to the outside world.\"\"\"\n    expose_mcp_server_port(self._core_v1, mcp_server.pod_name, self.namespace, mcp_server.config.port)\n</code></pre>"},{"location":"modules/#mcp_ephemeral_k8s.session_manager.KubernetesSessionManager.load_session_manager","title":"<code>load_session_manager()</code>","text":"<p>Load Kubernetes configuration from default location or from service account if running in cluster.</p> Source code in <code>src/mcp_ephemeral_k8s/session_manager.py</code> <pre><code>def load_session_manager(self) -&gt; Self:\n    \"\"\"Load Kubernetes configuration from default location or from service account if running in cluster.\"\"\"\n    self._load_kube_config()\n    if not hasattr(self, \"_api_client\"):\n        self._api_client = ApiClient()\n    if not hasattr(self, \"_batch_v1\"):\n        self._batch_v1 = BatchV1Api(self._api_client)\n    if not hasattr(self, \"_core_v1\"):\n        self._core_v1 = CoreV1Api(self._api_client)\n    # check if the configured namespace exists\n    namespaces = self._core_v1.list_namespace().items\n    if self.namespace not in [namespace.metadata.name for namespace in namespaces if namespace.metadata]:\n        raise MCPNamespaceNotFoundError(self.namespace)\n    return self\n</code></pre>"},{"location":"modules/#mcp_ephemeral_k8s.session_manager.KubernetesSessionManager.remove_mcp_server_port","title":"<code>remove_mcp_server_port(mcp_server)</code>","text":"<p>Remove the MCP server port from the outside world.</p> Source code in <code>src/mcp_ephemeral_k8s/session_manager.py</code> <pre><code>def remove_mcp_server_port(self, mcp_server: EphemeralMcpServer) -&gt; None:\n    \"\"\"Remove the MCP server port from the outside world.\"\"\"\n    remove_mcp_server_port(self._core_v1, mcp_server.pod_name, self.namespace)\n</code></pre>"},{"location":"modules/#mcp_ephemeral_k8s.app.mcp.create_mcp_server","title":"<code>create_mcp_server(ctx, runtime_exec, runtime_mcp, env=None, wait_for_ready=False)</code>","text":"<p>Create a new MCP server.</p> <p>Parameters:</p> Name Type Description Default <code>runtime_exec</code> <code>str</code> <p>The runtime to use for the MCP server (e.g. \"uvx\", \"npx\", \"go run\").</p> required <code>runtime_mcp</code> <code>str</code> <p>The runtime to use for the MCP server (e.g. \"mcp-server-fetch\").</p> required <code>env</code> <code>dict[str, str] | None</code> <p>The environment variables to set for the MCP server.</p> <code>None</code> <code>wait_for_ready</code> <code>bool</code> <p>Whether to wait for the MCP server to be ready before returning.</p> <code>False</code> Source code in <code>src/mcp_ephemeral_k8s/app/mcp.py</code> <pre><code>@mcp.tool(\"create_mcp_server\")\ndef create_mcp_server(\n    ctx: Context,\n    runtime_exec: str,\n    runtime_mcp: str,\n    env: dict[str, str] | None = None,\n    wait_for_ready: bool = False,\n) -&gt; EphemeralMcpServer:\n    \"\"\"Create a new MCP server.\n\n    Args:\n        runtime_exec: The runtime to use for the MCP server (e.g. \"uvx\", \"npx\", \"go run\").\n        runtime_mcp: The runtime to use for the MCP server (e.g. \"mcp-server-fetch\").\n        env: The environment variables to set for the MCP server.\n        wait_for_ready: Whether to wait for the MCP server to be ready before returning.\n    \"\"\"\n    config = EphemeralMcpServerConfig(runtime_exec=runtime_exec, runtime_mcp=runtime_mcp, env=env)\n    session_manager: KubernetesSessionManager = ctx.request_context.lifespan_context\n    return session_manager.create_mcp_server(config, wait_for_ready=wait_for_ready)\n</code></pre>"},{"location":"modules/#mcp_ephemeral_k8s.app.mcp.delete_mcp_server","title":"<code>delete_mcp_server(ctx, pod_name, wait_for_deletion=False)</code>","text":"<p>Delete an MCP server.</p> <p>Parameters:</p> Name Type Description Default <code>pod_name</code> <code>str</code> <p>The name of the MCP server to delete.</p> required <code>wait_for_deletion</code> <code>bool</code> <p>Whether to wait for the MCP server to be deleted before returning.</p> <code>False</code> Source code in <code>src/mcp_ephemeral_k8s/app/mcp.py</code> <pre><code>@mcp.tool(\"delete_mcp_server\")\ndef delete_mcp_server(ctx: Context, pod_name: str, wait_for_deletion: bool = False) -&gt; EphemeralMcpServer:\n    \"\"\"Delete an MCP server.\n\n    Args:\n        pod_name: The name of the MCP server to delete.\n        wait_for_deletion: Whether to wait for the MCP server to be deleted before returning.\n    \"\"\"\n    session_manager: KubernetesSessionManager = ctx.request_context.lifespan_context\n    return session_manager.delete_mcp_server(pod_name, wait_for_deletion=wait_for_deletion)\n</code></pre>"},{"location":"modules/#mcp_ephemeral_k8s.app.mcp.get_mcp_server_status","title":"<code>get_mcp_server_status(ctx, pod_name)</code>","text":"<p>Get the status of an MCP server.</p> <p>Parameters:</p> Name Type Description Default <code>pod_name</code> <code>str</code> <p>The name of the MCP server to get the status of.</p> required Source code in <code>src/mcp_ephemeral_k8s/app/mcp.py</code> <pre><code>@mcp.tool(\"get_mcp_server_status\")\ndef get_mcp_server_status(ctx: Context, pod_name: str) -&gt; client.V1Job | None:\n    \"\"\"Get the status of an MCP server.\n\n    Args:\n        pod_name: The name of the MCP server to get the status of.\n    \"\"\"\n    session_manager: KubernetesSessionManager = ctx.request_context.lifespan_context\n    return session_manager._get_job_status(pod_name)\n</code></pre>"},{"location":"modules/#mcp_ephemeral_k8s.app.mcp.get_version","title":"<code>get_version()</code>","text":"<p>Get the version of the MCP ephemeral server.</p> Source code in <code>src/mcp_ephemeral_k8s/app/mcp.py</code> <pre><code>@mcp.resource(\"config://version\")\ndef get_version() -&gt; str:\n    \"\"\"Get the version of the MCP ephemeral server.\"\"\"\n    return __version__\n</code></pre>"},{"location":"modules/#mcp_ephemeral_k8s.app.mcp.lifespan","title":"<code>lifespan(server)</code>  <code>async</code>","text":"<p>Lifecycle hooks for the MCP ephemeral server.</p> Source code in <code>src/mcp_ephemeral_k8s/app/mcp.py</code> <pre><code>@asynccontextmanager\nasync def lifespan(server: FastMCP) -&gt; AsyncIterator[KubernetesSessionManager]:\n    \"\"\"\n    Lifecycle hooks for the MCP ephemeral server.\n    \"\"\"\n    with KubernetesSessionManager(namespace=\"default\", jobs={}, sleep_time=1, max_wait_time=60) as session_manager:\n        yield session_manager\n</code></pre>"},{"location":"modules/#mcp_ephemeral_k8s.app.mcp.list_mcp_servers","title":"<code>list_mcp_servers(ctx)</code>","text":"<p>List all running MCP servers.</p> Source code in <code>src/mcp_ephemeral_k8s/app/mcp.py</code> <pre><code>@mcp.tool(\"list_mcp_servers\")\ndef list_mcp_servers(ctx: Context) -&gt; list[EphemeralMcpServer]:\n    \"\"\"List all running MCP servers.\"\"\"\n    session_manager: KubernetesSessionManager = ctx.request_context.lifespan_context\n    return list(session_manager.jobs.values())\n</code></pre>"},{"location":"modules/#mcp_ephemeral_k8s.app.mcp.list_presets","title":"<code>list_presets()</code>","text":"<p>List all preset configurations.</p> Source code in <code>src/mcp_ephemeral_k8s/app/mcp.py</code> <pre><code>@mcp.resource(\"config://presets\")\ndef list_presets() -&gt; list[EphemeralMcpServerConfig]:\n    \"\"\"List all preset configurations.\"\"\"\n    return [presets.FETCH, presets.GITHUB, presets.GITLAB, presets.GIT, presets.TIME, presets.BEDROCK_KB_RETRIEVAL]\n</code></pre>"},{"location":"modules/#mcp_ephemeral_k8s.app.fastapi.lifespan","title":"<code>lifespan(app)</code>  <code>async</code>","text":"<p>Lifecycle hooks for the MCP ephemeral server.</p> Source code in <code>src/mcp_ephemeral_k8s/app/fastapi.py</code> <pre><code>@asynccontextmanager\nasync def lifespan(app: FastAPI) -&gt; AsyncIterator[None]:\n    \"\"\"\n    Lifecycle hooks for the MCP ephemeral server.\n    \"\"\"\n    with KubernetesSessionManager() as session_manager:\n        app.state.session_manager = session_manager\n        yield\n    # the session manager will be deleted when the context manager is exited\n    del app.state.session_manager\n</code></pre>"},{"location":"modules/#mcp_ephemeral_k8s.api.ephemeral_mcp_server.EphemeralMcpServer","title":"<code>EphemeralMcpServer</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>The MCP server that is running in a Kubernetes pod.</p> Source code in <code>src/mcp_ephemeral_k8s/api/ephemeral_mcp_server.py</code> <pre><code>class EphemeralMcpServer(BaseModel):\n    \"\"\"The MCP server that is running in a Kubernetes pod.\"\"\"\n\n    pod_name: str = Field(\n        description=\"The name of the pod that is running the MCP server\", examples=[\"mcp-ephemeral-k8s-proxy-test\"]\n    )\n    config: EphemeralMcpServerConfig = Field(\n        description=\"The configuration that was used to create the MCP server\",\n        examples=[\n            EphemeralMcpServerConfig(\n                runtime_exec=\"uvx\",\n                runtime_mcp=\"mcp-server-fetch\",\n                port=8000,\n                cors_origins=[\"*\"],\n            )\n        ],\n    )\n\n    @computed_field  # type: ignore[prop-decorator]\n    @property\n    def url(self) -&gt; HttpUrl:\n        \"\"\"The Uniform Resource Locator (URL) for the MCP server.\"\"\"\n        return HttpUrl(f\"http://{self.pod_name}.default.svc.cluster.local:{self.config.port}/\")\n\n    @computed_field  # type: ignore[prop-decorator]\n    @property\n    def sse_url(self) -&gt; HttpUrl:\n        \"\"\"The Server-Sent Events (SSE) URL for the MCP server.\"\"\"\n        return HttpUrl(f\"{self.url}sse\")\n</code></pre>"},{"location":"modules/#mcp_ephemeral_k8s.api.ephemeral_mcp_server.EphemeralMcpServer.sse_url","title":"<code>sse_url</code>  <code>property</code>","text":"<p>The Server-Sent Events (SSE) URL for the MCP server.</p>"},{"location":"modules/#mcp_ephemeral_k8s.api.ephemeral_mcp_server.EphemeralMcpServer.url","title":"<code>url</code>  <code>property</code>","text":"<p>The Uniform Resource Locator (URL) for the MCP server.</p>"},{"location":"modules/#mcp_ephemeral_k8s.api.ephemeral_mcp_server.EphemeralMcpServerConfig","title":"<code>EphemeralMcpServerConfig</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Configuration for Kubernetes resources.</p> Source code in <code>src/mcp_ephemeral_k8s/api/ephemeral_mcp_server.py</code> <pre><code>class EphemeralMcpServerConfig(BaseModel):\n    \"\"\"Configuration for Kubernetes resources.\"\"\"\n\n    runtime_exec: str | None = Field(\n        description=\"The runtime to use for the MCP container. When None, the image is assumed to be a MCP server instead of a proxy.\",\n        examples=[\"uvx\", \"npx\"],\n    )\n    runtime_mcp: str | None = Field(\n        description=\"The runtime to use for the MCP container. Can be any supported MCP server runtime loadable via the `runtime_exec`. See the [MCP Server Runtimes](https://github.com/modelcontextprotocol/servers/tree/main) for a list of supported runtimes.\",\n        examples=[\"mcp-server-fetch\", \"@modelcontextprotocol/server-github\"],\n    )\n    image: str = Field(\n        default=\"ghcr.io/bobmerkus/mcp-ephemeral-k8s-proxy:latest\",\n        description=\"The image to use for the MCP server proxy\",\n    )\n    entrypoint: list[str] | None = Field(\n        default=[\"mcp-proxy\"],\n        description=\"The entrypoint for the MCP container. Normally not changed unless a custom image is used.\",\n    )\n    host: str = Field(default=\"0.0.0.0\", description=\"The host to expose the MCP server on\")  # noqa: S104\n    port: int = Field(default=8080, description=\"The port to expose the MCP server on\")\n    resource_requests: dict[str, str] = Field(\n        default={\"cpu\": \"100m\", \"memory\": \"100Mi\"}, description=\"Resource requests for the container\"\n    )\n    resource_limits: dict[str, str] = Field(\n        default={\"cpu\": \"200m\", \"memory\": \"200Mi\"}, description=\"Resource limits for the container\"\n    )\n    env: dict[str, str] | None = Field(\n        default=None,\n        description=\"Environment variables to set for the container\",\n        examples=[None, {\"GITHUB_PERSONAL_ACCESS_TOKEN\": \"1234567890\", \"GITHUB_DYNAMIC_TOOLSETS\": \"1\"}],\n    )\n    cors_origins: list[str] | None = Field(\n        default=[\"*\"],\n        description=\"The origins to allow CORS from\",\n        examples=[\"*\"],\n    )\n    probe_config: KubernetesProbeConfig = Field(\n        default_factory=KubernetesProbeConfig,\n        description=\"The configuration for the Kubernetes probe\",\n    )\n\n    @model_validator(mode=\"after\")\n    def validate_runtime_exec(self) -&gt; Self:\n        \"\"\"Validate the runtime configuration.\n        Both runtime_exec and runtime_mcp must be specified, or neither.\n        \"\"\"\n        if self.runtime_exec is not None and self.runtime_mcp is None:\n            message = \"Invalid runtime: runtime_exec is specified but runtime_mcp is not\"\n            raise MCPInvalidRuntimeError(runtime_exec=self.runtime_exec, runtime_mcp=self.runtime_mcp, message=message)\n        if self.runtime_exec is None and self.runtime_mcp is not None:\n            message = \"Invalid runtime: runtime_mcp is specified but runtime_exec is not\"\n            raise MCPInvalidRuntimeError(runtime_exec=self.runtime_exec, runtime_mcp=self.runtime_mcp, message=message)\n        return self\n\n    @computed_field  # type: ignore[prop-decorator]\n    @property\n    def args(self) -&gt; list[str] | None:\n        \"\"\"The arguments to pass to the MCP server.\n        [mcp-proxy](https://github.com/sparfenyuk/mcp-proxy?tab=readme-ov-file#21-configuration)\"\"\"\n        if self.runtime_exec is not None and self.runtime_mcp is not None:\n            args = [\n                \"--pass-environment\",\n                f\"--sse-port={self.port}\",\n                f\"--sse-host={self.host}\",\n                self.runtime_exec,\n                self.runtime_mcp,\n            ]\n            if self.cors_origins is not None:\n                args.extend([\"--allow-origin\", *self.cors_origins])\n            return args\n        return None\n\n    @computed_field  # type: ignore[prop-decorator]\n    @property\n    def image_name(self) -&gt; str:\n        \"\"\"The name of the image to use for the MCP server.\"\"\"\n        return self.image.split(\"/\")[-1].split(\":\")[0]\n\n    @computed_field  # type: ignore[prop-decorator]\n    @property\n    def job_name(self) -&gt; str:\n        \"\"\"The name of the job to use for the MCP server.\"\"\"\n        return generate_unique_id(prefix=self.image_name)\n\n    @classmethod\n    def from_docker_image(cls, image: str, entrypoint: list[str] | None = None, **kwargs: Any) -&gt; Self:\n        \"\"\"Create an EphemeralMcpServerConfig from a Docker image.\n        The image must be a MCP server image, otherwise an error is raised.\n        \"\"\"\n        if image.startswith(\"ghcr.io/bobmerkus/mcp-ephemeral-k8s-proxy\") or image.startswith(\n            \"ghcr.io/sparfenyuk/mcp-proxy\"\n        ):\n            message = \"Invalid runtime: image is a proxy image, please use the `runtime_exec` and `runtime_mcp` fields to specify the MCP server to use.\"\n            raise MCPInvalidRuntimeError(runtime_exec=None, runtime_mcp=None, message=message)\n        return cls(image=image, entrypoint=entrypoint, runtime_exec=None, runtime_mcp=None, **kwargs)\n</code></pre>"},{"location":"modules/#mcp_ephemeral_k8s.api.ephemeral_mcp_server.EphemeralMcpServerConfig.args","title":"<code>args</code>  <code>property</code>","text":"<p>The arguments to pass to the MCP server. mcp-proxy</p>"},{"location":"modules/#mcp_ephemeral_k8s.api.ephemeral_mcp_server.EphemeralMcpServerConfig.image_name","title":"<code>image_name</code>  <code>property</code>","text":"<p>The name of the image to use for the MCP server.</p>"},{"location":"modules/#mcp_ephemeral_k8s.api.ephemeral_mcp_server.EphemeralMcpServerConfig.job_name","title":"<code>job_name</code>  <code>property</code>","text":"<p>The name of the job to use for the MCP server.</p>"},{"location":"modules/#mcp_ephemeral_k8s.api.ephemeral_mcp_server.EphemeralMcpServerConfig.from_docker_image","title":"<code>from_docker_image(image, entrypoint=None, **kwargs)</code>  <code>classmethod</code>","text":"<p>Create an EphemeralMcpServerConfig from a Docker image. The image must be a MCP server image, otherwise an error is raised.</p> Source code in <code>src/mcp_ephemeral_k8s/api/ephemeral_mcp_server.py</code> <pre><code>@classmethod\ndef from_docker_image(cls, image: str, entrypoint: list[str] | None = None, **kwargs: Any) -&gt; Self:\n    \"\"\"Create an EphemeralMcpServerConfig from a Docker image.\n    The image must be a MCP server image, otherwise an error is raised.\n    \"\"\"\n    if image.startswith(\"ghcr.io/bobmerkus/mcp-ephemeral-k8s-proxy\") or image.startswith(\n        \"ghcr.io/sparfenyuk/mcp-proxy\"\n    ):\n        message = \"Invalid runtime: image is a proxy image, please use the `runtime_exec` and `runtime_mcp` fields to specify the MCP server to use.\"\n        raise MCPInvalidRuntimeError(runtime_exec=None, runtime_mcp=None, message=message)\n    return cls(image=image, entrypoint=entrypoint, runtime_exec=None, runtime_mcp=None, **kwargs)\n</code></pre>"},{"location":"modules/#mcp_ephemeral_k8s.api.ephemeral_mcp_server.EphemeralMcpServerConfig.validate_runtime_exec","title":"<code>validate_runtime_exec()</code>","text":"<p>Validate the runtime configuration. Both runtime_exec and runtime_mcp must be specified, or neither.</p> Source code in <code>src/mcp_ephemeral_k8s/api/ephemeral_mcp_server.py</code> <pre><code>@model_validator(mode=\"after\")\ndef validate_runtime_exec(self) -&gt; Self:\n    \"\"\"Validate the runtime configuration.\n    Both runtime_exec and runtime_mcp must be specified, or neither.\n    \"\"\"\n    if self.runtime_exec is not None and self.runtime_mcp is None:\n        message = \"Invalid runtime: runtime_exec is specified but runtime_mcp is not\"\n        raise MCPInvalidRuntimeError(runtime_exec=self.runtime_exec, runtime_mcp=self.runtime_mcp, message=message)\n    if self.runtime_exec is None and self.runtime_mcp is not None:\n        message = \"Invalid runtime: runtime_mcp is specified but runtime_exec is not\"\n        raise MCPInvalidRuntimeError(runtime_exec=self.runtime_exec, runtime_mcp=self.runtime_mcp, message=message)\n    return self\n</code></pre>"},{"location":"modules/#mcp_ephemeral_k8s.api.ephemeral_mcp_server.KubernetesProbeConfig","title":"<code>KubernetesProbeConfig</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>The configuration for the Kubernetes probe.</p> Source code in <code>src/mcp_ephemeral_k8s/api/ephemeral_mcp_server.py</code> <pre><code>class KubernetesProbeConfig(BaseModel):\n    \"\"\"The configuration for the Kubernetes probe.\"\"\"\n\n    initial_delay_seconds: int = Field(default=10, description=\"The initial delay seconds for the probe\")\n    period_seconds: int = Field(default=1, description=\"The period seconds for the probe\")\n    timeout_seconds: int = Field(default=2, description=\"The timeout seconds for the probe\")\n    success_threshold: int = Field(default=1, description=\"The success threshold for the probe\")\n    failure_threshold: int = Field(default=300, description=\"The failure threshold for the probe\")\n</code></pre>"},{"location":"modules/#mcp_ephemeral_k8s.api.ephemeral_mcp_server.KubernetesRuntime","title":"<code>KubernetesRuntime</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>The runtime that is being used for Kubeconfig</p> Source code in <code>src/mcp_ephemeral_k8s/api/ephemeral_mcp_server.py</code> <pre><code>class KubernetesRuntime(str, Enum):\n    \"\"\"The runtime that is being used for Kubeconfig\"\"\"\n\n    KUBECONFIG = \"KUBECONFIG\"\n    INCLUSTER = \"INCLUSTER\"\n</code></pre>"},{"location":"modules/#mcp_ephemeral_k8s.api.exceptions.InvalidKubeConfigError","title":"<code>InvalidKubeConfigError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Exception raised when the kube config is invalid.</p> Source code in <code>src/mcp_ephemeral_k8s/api/exceptions.py</code> <pre><code>class InvalidKubeConfigError(Exception):\n    \"\"\"Exception raised when the kube config is invalid.\"\"\"\n\n    def __init__(self, message: str):\n        self.message = f\"Invalid kube config: {message}\"\n        super().__init__(self.message)\n</code></pre>"},{"location":"modules/#mcp_ephemeral_k8s.api.exceptions.MCPInvalidRuntimeError","title":"<code>MCPInvalidRuntimeError</code>","text":"<p>               Bases: <code>ValueError</code></p> <p>An error that occurs when the runtime is invalid.</p> Source code in <code>src/mcp_ephemeral_k8s/api/exceptions.py</code> <pre><code>class MCPInvalidRuntimeError(ValueError):\n    \"\"\"An error that occurs when the runtime is invalid.\"\"\"\n\n    def __init__(self, runtime_exec: str | None, runtime_mcp: str | None, message: str) -&gt; None:\n        super().__init__(f\"Invalid runtime: {runtime_exec=} and {runtime_mcp=} {message}\")\n</code></pre>"},{"location":"modules/#mcp_ephemeral_k8s.api.exceptions.MCPJobError","title":"<code>MCPJobError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Exception raised when the MCP job is in an error state.</p> Source code in <code>src/mcp_ephemeral_k8s/api/exceptions.py</code> <pre><code>class MCPJobError(Exception):\n    \"\"\"Exception raised when the MCP job is in an error state.\"\"\"\n\n    def __init__(self, namespace: str, pod_name: str, message: str):\n        self.message = f\"MCP job error: {namespace=} {pod_name=} - {message}\"\n        super().__init__(self.message)\n</code></pre>"},{"location":"modules/#mcp_ephemeral_k8s.api.exceptions.MCPJobNotFoundError","title":"<code>MCPJobNotFoundError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Exception raised when the MCP job is not found.</p> Source code in <code>src/mcp_ephemeral_k8s/api/exceptions.py</code> <pre><code>class MCPJobNotFoundError(Exception):\n    \"\"\"Exception raised when the MCP job is not found.\"\"\"\n\n    def __init__(self, namespace: str, pod_name: str):\n        self.message = f\"Failed to find MCP job: {namespace=} {pod_name=}\"\n        super().__init__(self.message)\n</code></pre>"},{"location":"modules/#mcp_ephemeral_k8s.api.exceptions.MCPJobTimeoutError","title":"<code>MCPJobTimeoutError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Exception raised when the MCP job times out.</p> Source code in <code>src/mcp_ephemeral_k8s/api/exceptions.py</code> <pre><code>class MCPJobTimeoutError(Exception):\n    \"\"\"Exception raised when the MCP job times out.\"\"\"\n\n    def __init__(self, namespace: str, pod_name: str):\n        self.message = f\"MCP job timed out: {namespace=} {pod_name=}\"\n        super().__init__(self.message)\n</code></pre>"},{"location":"modules/#mcp_ephemeral_k8s.api.exceptions.MCPNamespaceNotFoundError","title":"<code>MCPNamespaceNotFoundError</code>","text":"<p>               Bases: <code>ValueError</code></p> <p>An error that occurs when the namespace is not found.</p> Source code in <code>src/mcp_ephemeral_k8s/api/exceptions.py</code> <pre><code>class MCPNamespaceNotFoundError(ValueError):\n    \"\"\"An error that occurs when the namespace is not found.\"\"\"\n\n    def __init__(self, namespace: str):\n        self.message = f\"Namespace not found: {namespace}\"\n        super().__init__(self.message)\n</code></pre>"},{"location":"modules/#mcp_ephemeral_k8s.api.exceptions.MCPPortForwardError","title":"<code>MCPPortForwardError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Exception raised when the MCP port forward fails.</p> Source code in <code>src/mcp_ephemeral_k8s/api/exceptions.py</code> <pre><code>class MCPPortForwardError(Exception):\n    \"\"\"Exception raised when the MCP port forward fails.\"\"\"\n\n    def __init__(self, pod_name: str, namespace: str, port: int):\n        self.message = f\"Failed to create port forward: {pod_name=} {namespace=} {port=}\"\n        super().__init__(self.message)\n</code></pre>"},{"location":"modules/#mcp_ephemeral_k8s.api.exceptions.MCPServerCreationError","title":"<code>MCPServerCreationError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Exception raised when the MCP server creation fails.</p> Source code in <code>src/mcp_ephemeral_k8s/api/exceptions.py</code> <pre><code>class MCPServerCreationError(Exception):\n    \"\"\"Exception raised when the MCP server creation fails.\"\"\"\n\n    def __init__(self, message: str):\n        self.message = f\"Failed to create MCP server: {message}\"\n        super().__init__(self.message)\n</code></pre>"},{"location":"modules/#mcp_ephemeral_k8s.k8s.job.check_pod_status","title":"<code>check_pod_status(core_v1, pod_name, namespace)</code>","text":"<p>Check the status of pods associated with a job.</p> <p>Parameters:</p> Name Type Description Default <code>core_v1</code> <code>CoreV1Api</code> <p>The Kubernetes core API client</p> required <code>pod_name</code> <code>str</code> <p>Name of the job/pod</p> required <code>namespace</code> <code>str</code> <p>Kubernetes namespace</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if a pod is running and ready (probes successful), False if waiting for pods</p> <p>Raises:</p> Type Description <code>MCPJobError</code> <p>If a pod is in Failed or Unknown state</p> Source code in <code>src/mcp_ephemeral_k8s/k8s/job.py</code> <pre><code>def check_pod_status(core_v1: client.CoreV1Api, pod_name: str, namespace: str) -&gt; bool:  # noqa: C901\n    \"\"\"\n    Check the status of pods associated with a job.\n\n    Args:\n        core_v1: The Kubernetes core API client\n        pod_name: Name of the job/pod\n        namespace: Kubernetes namespace\n\n    Returns:\n        True if a pod is running and ready (probes successful), False if waiting for pods\n\n    Raises:\n        MCPJobError: If a pod is in Failed or Unknown state\n    \"\"\"\n    pods = core_v1.list_namespaced_pod(namespace=namespace, label_selector=f\"job-name={pod_name}\")\n    if not pods.items:\n        logger.warning(f\"No pods found for job '{pod_name}', waiting...\")\n        return False\n    for pod in pods.items:\n        if pod.status and pod.status.phase:\n            if pod.status.phase in [\"Failed\", \"Unknown\"]:\n                if pod.metadata is not None and pod.metadata.name is not None:\n                    logs = core_v1.read_namespaced_pod_log(name=pod.metadata.name, namespace=namespace)\n                    logger.error(f\"Pod {pod.metadata.name} in error state: {pod.status.phase}\")\n                    logger.error(f\"Logs: {logs}\")\n                    message = f\"Pod is in error state: {pod.status.phase}. Logs: {logs}\"\n                else:\n                    message = f\"Pod is in error state: {pod.status.phase}\"\n                raise MCPJobError(namespace, pod_name, message)\n            elif pod.status.phase == \"Running\":\n                is_ready = False\n                if pod.status.conditions:\n                    for condition in pod.status.conditions:\n                        if condition.type == \"Ready\" and condition.status == \"True\":\n                            is_ready = True\n                            break\n\n                if is_ready:\n                    logger.info(f\"Job '{pod_name}' pod is running and ready (probes successful)\")\n                    return True\n                else:\n                    logger.info(f\"Job '{pod_name}' pod is running but not ready yet (waiting for probes)\")\n    return False\n</code></pre>"},{"location":"modules/#mcp_ephemeral_k8s.k8s.job.create_mcp_server_job","title":"<code>create_mcp_server_job(config, namespace)</code>","text":"<p>Create a job that will run until explicitly terminated.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>EphemeralMcpServerConfig</code> <p>The configuration for the MCP server</p> required <code>namespace</code> <code>str</code> <p>Kubernetes namespace</p> required <p>Returns:</p> Type Description <code>V1Job</code> <p>The MCP server instance</p> Source code in <code>src/mcp_ephemeral_k8s/k8s/job.py</code> <pre><code>def create_mcp_server_job(config: EphemeralMcpServerConfig, namespace: str) -&gt; client.V1Job:\n    \"\"\"\n    Create a job that will run until explicitly terminated.\n\n    Args:\n        config: The configuration for the MCP server\n        namespace: Kubernetes namespace\n\n    Returns:\n        The MCP server instance\n    \"\"\"\n    # Convert environment variables dictionary to list of V1EnvVar\n    env_list = [client.V1EnvVar(name=key, value=value) for key, value in (config.env or {}).items()]\n\n    # Configure the job\n    job = client.V1Job(\n        api_version=\"batch/v1\",\n        kind=\"Job\",\n        metadata=client.V1ObjectMeta(name=config.job_name, namespace=namespace),\n        spec=client.V1JobSpec(\n            backoff_limit=10,\n            template=client.V1PodTemplateSpec(\n                metadata=client.V1ObjectMeta(labels={\"app\": config.job_name}),\n                spec=client.V1PodSpec(\n                    containers=[\n                        client.V1Container(\n                            name=config.job_name,\n                            image=config.image,\n                            command=config.entrypoint,\n                            image_pull_policy=\"IfNotPresent\",\n                            args=config.args,\n                            resources=client.V1ResourceRequirements(\n                                requests=config.resource_requests, limits=config.resource_limits\n                            ),\n                            ports=[client.V1ContainerPort(container_port=config.port)],\n                            env=env_list,\n                            readiness_probe=client.V1Probe(\n                                tcp_socket=client.V1TCPSocketAction(port=config.port),\n                                **config.probe_config.model_dump(),\n                            ),\n                        )\n                    ],\n                    restart_policy=\"Never\",\n                ),\n            ),\n        ),\n    )\n\n    return job\n</code></pre>"},{"location":"modules/#mcp_ephemeral_k8s.k8s.job.delete_mcp_server_job","title":"<code>delete_mcp_server_job(core_v1, batch_v1, pod_name, namespace)</code>","text":"<p>Delete a Kubernetes job and its associated pods.</p> <p>Parameters:</p> Name Type Description Default <code>core_v1</code> <code>CoreV1Api</code> <p>The Kubernetes core API client</p> required <code>batch_v1</code> <code>BatchV1Api</code> <p>The Kubernetes batch API client</p> required <code>pod_name</code> <code>str</code> <p>The name of the pod to delete</p> required <code>namespace</code> <code>str</code> <p>The namespace of the pod</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the job was deleted successfully, False otherwise</p> Source code in <code>src/mcp_ephemeral_k8s/k8s/job.py</code> <pre><code>def delete_mcp_server_job(\n    core_v1: client.CoreV1Api, batch_v1: client.BatchV1Api, pod_name: str, namespace: str\n) -&gt; bool:\n    \"\"\"\n    Delete a Kubernetes job and its associated pods.\n\n    Args:\n        core_v1: The Kubernetes core API client\n        batch_v1: The Kubernetes batch API client\n        pod_name: The name of the pod to delete\n        namespace: The namespace of the pod\n\n    Returns:\n        True if the job was deleted successfully, False otherwise\n    \"\"\"\n    try:\n        pods = core_v1.list_namespaced_pod(namespace=namespace, label_selector=f\"app={pod_name}\")\n        for pod in pods.items:\n            if pod.metadata is None:\n                continue\n            pod_name_to_delete = pod.metadata.name\n            if pod_name_to_delete is None:\n                continue\n            logger.info(f\"Deleting pod {pod_name_to_delete}\")\n            core_v1.delete_namespaced_pod(\n                name=pod_name_to_delete,\n                namespace=namespace,\n                body=client.V1DeleteOptions(grace_period_seconds=0, propagation_policy=\"Background\"),\n            )\n    except ApiException as e:\n        logger.info(f\"Error deleting pods: {e}\")\n        return False\n    try:\n        batch_v1.delete_namespaced_job(\n            name=pod_name, namespace=namespace, body=client.V1DeleteOptions(propagation_policy=\"Foreground\")\n        )\n        logger.info(f\"Job '{pod_name}' deleted successfully\")\n    except ApiException as e:\n        logger.info(f\"Error deleting job: {e}\")\n        return False\n    else:\n        return True\n</code></pre>"},{"location":"modules/#mcp_ephemeral_k8s.k8s.job.expose_mcp_server_port","title":"<code>expose_mcp_server_port(core_v1, pod_name, namespace, port)</code>","text":"<p>Expose the MCP server port to the outside world.</p> <p>Parameters:</p> Name Type Description Default <code>core_v1</code> <code>CoreV1Api</code> <p>The Kubernetes core API client</p> required <code>pod_name</code> <code>str</code> <p>Name of the pod</p> required <code>namespace</code> <code>str</code> <p>Kubernetes namespace</p> required <code>port</code> <code>int</code> <p>Port to expose</p> required Source code in <code>src/mcp_ephemeral_k8s/k8s/job.py</code> <pre><code>def expose_mcp_server_port(core_v1: client.CoreV1Api, pod_name: str, namespace: str, port: int) -&gt; None:\n    \"\"\"\n    Expose the MCP server port to the outside world.\n\n    Args:\n        core_v1: The Kubernetes core API client\n        pod_name: Name of the pod\n        namespace: Kubernetes namespace\n        port: Port to expose\n    \"\"\"\n    core_v1.create_namespaced_service(\n        namespace=namespace,\n        body=client.V1Service(\n            metadata=client.V1ObjectMeta(name=pod_name),\n            spec=client.V1ServiceSpec(\n                selector={\"app\": pod_name},\n                ports=[client.V1ServicePort(port=port)],\n            ),\n        ),\n    )\n    logger.info(f\"Service '{pod_name}' created successfully\")\n</code></pre>"},{"location":"modules/#mcp_ephemeral_k8s.k8s.job.get_mcp_server_job_status","title":"<code>get_mcp_server_job_status(batch_v1, pod_name, namespace)</code>","text":"<p>Get the status of a Kubernetes job.</p> <p>Parameters:</p> Name Type Description Default <code>batch_v1</code> <code>BatchV1Api</code> <p>The Kubernetes batch API client</p> required <code>pod_name</code> <code>str</code> <p>The name of the pod to get the status of</p> required <code>namespace</code> <code>str</code> <p>The namespace of the pod</p> required <p>Returns:</p> Type Description <code>None | V1Job</code> <p>The status of the job</p> Source code in <code>src/mcp_ephemeral_k8s/k8s/job.py</code> <pre><code>def get_mcp_server_job_status(batch_v1: client.BatchV1Api, pod_name: str, namespace: str) -&gt; None | client.V1Job:\n    \"\"\"\n    Get the status of a Kubernetes job.\n\n    Args:\n        batch_v1: The Kubernetes batch API client\n        pod_name: The name of the pod to get the status of\n        namespace: The namespace of the pod\n\n    Returns:\n        The status of the job\n    \"\"\"\n    try:\n        job = batch_v1.read_namespaced_job(name=pod_name, namespace=namespace)\n\n        # Get status\n        if job.status is not None:\n            active = job.status.active if job.status.active is not None else 0\n            succeeded = job.status.succeeded if job.status.succeeded is not None else 0\n            failed = job.status.failed if job.status.failed is not None else 0\n\n            logger.info(f\"Job '{pod_name}' status:\")\n            logger.info(f\"Active pods: {active}\")\n            logger.info(f\"Succeeded pods: {succeeded}\")\n            logger.info(f\"Failed pods: {failed}\")\n\n        # Get job creation time\n        if job.metadata is not None and job.metadata.creation_timestamp is not None:\n            creation_time = job.metadata.creation_timestamp\n            logger.info(f\"Creation time: {creation_time}\")\n    except ApiException as e:\n        if e.status == 404:\n            logger.info(f\"Job '{pod_name}' not found\")\n        else:\n            logger.info(f\"Error getting job status: {e}\")\n        return None\n    else:\n        return job\n</code></pre>"},{"location":"modules/#mcp_ephemeral_k8s.k8s.job.remove_mcp_server_port","title":"<code>remove_mcp_server_port(core_v1, pod_name, namespace)</code>","text":"<p>Remove the MCP server port from the outside world.</p> <p>Parameters:</p> Name Type Description Default <code>core_v1</code> <code>CoreV1Api</code> <p>The Kubernetes core API client</p> required <code>pod_name</code> <code>str</code> <p>Name of the pod</p> required <code>namespace</code> <code>str</code> <p>Kubernetes namespace</p> required Source code in <code>src/mcp_ephemeral_k8s/k8s/job.py</code> <pre><code>def remove_mcp_server_port(core_v1: client.CoreV1Api, pod_name: str, namespace: str) -&gt; None:\n    \"\"\"\n    Remove the MCP server port from the outside world.\n\n    Args:\n        core_v1: The Kubernetes core API client\n        pod_name: Name of the pod\n        namespace: Kubernetes namespace\n    \"\"\"\n    core_v1.delete_namespaced_service(name=pod_name, namespace=namespace)\n    logger.info(f\"Service '{pod_name}' deleted successfully\")\n</code></pre>"},{"location":"modules/#mcp_ephemeral_k8s.k8s.job.wait_for_job_deletion","title":"<code>wait_for_job_deletion(batch_v1, pod_name, namespace, sleep_time=1, max_wait_time=60)</code>","text":"<p>Wait for a job to be deleted.</p> <p>Parameters:</p> Name Type Description Default <code>batch_v1</code> <code>BatchV1Api</code> <p>The Kubernetes batch API client</p> required <code>pod_name</code> <code>str</code> <p>Name of the pod</p> required <code>namespace</code> <code>str</code> <p>Kubernetes namespace</p> required <code>sleep_time</code> <code>float</code> <p>Time to sleep between checks</p> <code>1</code> <code>max_wait_time</code> <code>float</code> <p>Maximum time to wait before timing out</p> <code>60</code> <p>Raises:</p> Type Description <code>MCPJobTimeoutError</code> <p>If the job is not deleted within max_wait_time</p> Source code in <code>src/mcp_ephemeral_k8s/k8s/job.py</code> <pre><code>def wait_for_job_deletion(\n    batch_v1: client.BatchV1Api, pod_name: str, namespace: str, sleep_time: float = 1, max_wait_time: float = 60\n) -&gt; None:\n    \"\"\"\n    Wait for a job to be deleted.\n\n    Args:\n        batch_v1: The Kubernetes batch API client\n        pod_name: Name of the pod\n        namespace: Kubernetes namespace\n        sleep_time: Time to sleep between checks\n        max_wait_time: Maximum time to wait before timing out\n\n    Raises:\n        MCPJobTimeoutError: If the job is not deleted within max_wait_time\n    \"\"\"\n    start_time = time.time()\n    while True:\n        if time.time() - start_time &gt; max_wait_time:\n            raise MCPJobTimeoutError(namespace, pod_name)\n        if get_mcp_server_job_status(batch_v1, pod_name, namespace) is None:\n            break\n        time.sleep(sleep_time)\n</code></pre>"},{"location":"modules/#mcp_ephemeral_k8s.k8s.job.wait_for_job_ready","title":"<code>wait_for_job_ready(batch_v1, core_v1, pod_name, namespace, sleep_time=1, max_wait_time=60)</code>","text":"<p>Wait for a job's pod to be in the running state and ready (probes successful).</p> <p>Parameters:</p> Name Type Description Default <code>batch_v1</code> <code>BatchV1Api</code> <p>The Kubernetes batch API client</p> required <code>core_v1</code> <code>CoreV1Api</code> <p>The Kubernetes core API client</p> required <code>pod_name</code> <code>str</code> <p>Name of the pod</p> required <code>namespace</code> <code>str</code> <p>Kubernetes namespace</p> required <code>sleep_time</code> <code>float</code> <p>Time to sleep between checks</p> <code>1</code> <code>max_wait_time</code> <code>float</code> <p>Maximum time to wait before timing out</p> <code>60</code> <p>Raises:</p> Type Description <code>MCPJobTimeoutError</code> <p>If the job does not become ready within max_wait_time</p> Source code in <code>src/mcp_ephemeral_k8s/k8s/job.py</code> <pre><code>def wait_for_job_ready(\n    batch_v1: client.BatchV1Api,\n    core_v1: client.CoreV1Api,\n    pod_name: str,\n    namespace: str,\n    sleep_time: float = 1,\n    max_wait_time: float = 60,\n) -&gt; None:\n    \"\"\"\n    Wait for a job's pod to be in the running state and ready (probes successful).\n\n    Args:\n        batch_v1: The Kubernetes batch API client\n        core_v1: The Kubernetes core API client\n        pod_name: Name of the pod\n        namespace: Kubernetes namespace\n        sleep_time: Time to sleep between checks\n        max_wait_time: Maximum time to wait before timing out\n\n    Raises:\n        MCPJobTimeoutError: If the job does not become ready within max_wait_time\n    \"\"\"\n    start_time = time.time()\n    while True:\n        if time.time() - start_time &gt; max_wait_time:\n            raise MCPJobTimeoutError(namespace, pod_name)\n\n        job = get_mcp_server_job_status(batch_v1, pod_name, namespace)\n        if job is None:\n            logger.warning(f\"Job '{pod_name}' not found, waiting for pod to become ready...\")\n            time.sleep(sleep_time)\n            continue\n\n        if job.status is None:\n            logger.warning(f\"Job '{pod_name}' status is None, waiting for pod to become ready...\")\n            time.sleep(sleep_time)\n            continue\n\n        # Check if any pod is in running state and ready\n        if check_pod_status(core_v1, pod_name, namespace):\n            break\n\n        if job.status.active == 1:\n            logger.info(f\"Job '{pod_name}' active\")\n        else:\n            logger.warning(f\"Job '{pod_name}' in unknown state, waiting...\")\n\n        time.sleep(sleep_time)\n</code></pre>"},{"location":"modules/#mcp_ephemeral_k8s.k8s.uid.generate_unique_id","title":"<code>generate_unique_id(prefix=None, max_length=63)</code>","text":"<p>Generate a unique identifier that follows the Kubernetes naming rules (RFC 1123 Label Names).</p> <p>RFC 1123 Label Names must: - Contain only lowercase alphanumeric characters or '-' - Start with an alphanumeric character - End with an alphanumeric character - Be at most 63 characters</p> <p>Parameters:</p> Name Type Description Default <code>prefix</code> <code>str | None</code> <p>Optional prefix for the ID. Will be converted to lowercase and non-compliant     characters will be replaced with dashes.</p> <code>None</code> <code>max_length</code> <code>int</code> <p>Maximum length of the generated ID, defaults to 63 (K8s limit).</p> <code>63</code> <p>Returns:</p> Type Description <code>str</code> <p>A unique RFC 1123 compliant identifier string.</p> Source code in <code>src/mcp_ephemeral_k8s/k8s/uid.py</code> <pre><code>def generate_unique_id(prefix: str | None = None, max_length: int = 63) -&gt; str:\n    \"\"\"\n    Generate a unique identifier that follows the Kubernetes naming rules (RFC 1123 Label Names).\n\n    RFC 1123 Label Names must:\n    - Contain only lowercase alphanumeric characters or '-'\n    - Start with an alphanumeric character\n    - End with an alphanumeric character\n    - Be at most 63 characters\n\n    Args:\n        prefix: Optional prefix for the ID. Will be converted to lowercase and non-compliant\n                characters will be replaced with dashes.\n        max_length: Maximum length of the generated ID, defaults to 63 (K8s limit).\n\n    Returns:\n        A unique RFC 1123 compliant identifier string.\n    \"\"\"\n    # Process prefix if provided\n    processed_prefix = \"\"\n    if prefix:\n        # Convert to lowercase and replace invalid characters\n        processed_prefix = \"\".join(\n            c if c.isalnum() and c.islower() else (c.lower() if c.isalnum() else \"-\") for c in prefix\n        )\n\n        # Ensure prefix starts with alphanumeric\n        if processed_prefix and not processed_prefix[0].isalnum():\n            processed_prefix = f\"p{processed_prefix}\"\n\n        # Add separator\n        if processed_prefix:\n            processed_prefix = f\"{processed_prefix}-\"\n\n    # Generate a unique part (timestamp + random)\n    timestamp = str(int(time.time()))\n    random_chars = \"\".join(random.choices(string.ascii_lowercase + string.digits, k=8))  # noqa: S311\n    unique_part = f\"{timestamp}-{random_chars}\"\n\n    # Combine and ensure max length\n    full_id = f\"{processed_prefix}{unique_part}\"\n    if len(full_id) &gt; max_length:\n        # If too long, truncate the ID but keep the random part\n        chars_to_keep = max_length - len(random_chars) - 1\n        full_id = f\"{full_id[:chars_to_keep]}-{random_chars}\"\n\n    # Ensure ID ends with alphanumeric\n    if not full_id[-1].isalnum():\n        full_id = f\"{full_id[:-1]}{random.choice(string.ascii_lowercase)}\"  # noqa: S311\n\n    return full_id\n</code></pre>"}]}
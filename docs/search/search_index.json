{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"mcp-ephemeral-k8s","text":"<p>Python implementation to spawn ephemeral Model Context Protocol (MCP) servers using the kubernetes API.</p>"},{"location":"modules/","title":"API Reference","text":""},{"location":"modules/#core-session-management","title":"Core Session Management","text":"<p>This module contains the session manager for the MCP ephemeral K8s library. It is used to create and manage MCP servers in a Kubernetes cluster.</p>"},{"location":"modules/#mcp_ephemeral_k8s.session_manager.KubernetesSessionManager","title":"<code>KubernetesSessionManager</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Kubernetes session manager for MCP.</p> <p>This manager creates and manages Kubernetes jobs for MCP sessions. It implements the async context manager protocol for easy resource management.</p> Source code in <code>src/mcp_ephemeral_k8s/session_manager.py</code> <pre><code>class KubernetesSessionManager(BaseModel):\n    \"\"\"\n    Kubernetes session manager for MCP.\n\n    This manager creates and manages Kubernetes jobs for MCP sessions.\n    It implements the async context manager protocol for easy resource management.\n    \"\"\"\n\n    model_config = ConfigDict(arbitrary_types_allowed=True)\n\n    namespace: str = Field(default=\"default\", description=\"The namespace to create resources in\")\n    jobs: dict[str, EphemeralMcpServer] = Field(\n        default_factory=dict,\n        description=\"A dictionary mapping between pod names and MCP servers jobs that are running.\",\n    )\n    runtime: KubernetesRuntime = Field(\n        default=KubernetesRuntime.KUBECONFIG, description=\"The runtime to use for the MCP server\"\n    )\n    sleep_time: float = Field(default=1, description=\"The time to sleep between job status checks\")\n    max_wait_time: float = Field(default=300, description=\"The maximum time to wait for a job to complete\")\n    _api_client: ApiClient = PrivateAttr()\n    _batch_v1: BatchV1Api = PrivateAttr()\n    _core_v1: CoreV1Api = PrivateAttr()\n    _rbac_v1: RbacAuthorizationV1Api = PrivateAttr()\n\n    def load_session_manager(self) -&gt; Self:\n        \"\"\"Load Kubernetes configuration from default location or from service account if running in cluster.\"\"\"\n        self._load_kube_config()\n        if not hasattr(self, \"_api_client\"):\n            self._api_client = ApiClient()\n        if not hasattr(self, \"_batch_v1\"):\n            self._batch_v1 = BatchV1Api(self._api_client)\n        if not hasattr(self, \"_core_v1\"):\n            self._core_v1 = CoreV1Api(self._api_client)\n        if not hasattr(self, \"_rbac_v1\"):\n            self._rbac_v1 = RbacAuthorizationV1Api(self._api_client)\n        # Check if the configured namespace exists using direct read (more efficient than listing all)\n        try:\n            self._core_v1.read_namespace(name=self.namespace)\n        except Exception as e:\n            raise MCPNamespaceNotFoundError(self.namespace) from e\n        return self\n\n    def _load_kube_config(self) -&gt; None:\n        \"\"\"Load Kubernetes configuration from default location or from service account if running in cluster.\"\"\"\n        if self.runtime == KubernetesRuntime.KUBECONFIG:\n            try:\n                load_kube_config(\n                    config_file=os.environ.get(\"KUBECONFIG\"),\n                    context=os.environ.get(\"KUBECONTEXT\"),\n                    client_configuration=None,\n                    persist_config=False,\n                )\n            except (FileNotFoundError, OSError, ConfigException) as e:\n                logger.warning(f\"Failed to load local kubernetes configuration: {e}. Trying in-cluster configuration\")\n                self.runtime = KubernetesRuntime.INCLUSTER\n            else:\n                logger.info(\"Using local kubernetes configuration\")\n                return\n        if self.runtime == KubernetesRuntime.INCLUSTER:\n            try:\n                load_incluster_config()\n            except (FileNotFoundError, OSError) as e:\n                msg = \"Failed to load in-cluster configuration\"\n                raise InvalidKubeConfigError(msg) from e\n            else:\n                logger.info(\"Using in-cluster kubernetes configuration\")\n                return\n        raise InvalidKubeConfigError(self.runtime)\n\n    async def __aenter__(self) -&gt; Self:\n        \"\"\"Enter the async context manager.\"\"\"\n        self.load_session_manager()\n        return self\n\n    async def __aexit__(self, exc_type: Any, exc_val: Any, exc_tb: Any) -&gt; None:\n        \"\"\"Exit the async context manager.\"\"\"\n        for job_name in self.jobs:\n            await self._delete_job(job_name)\n\n    async def _create_job(self, config: EphemeralMcpServerConfig) -&gt; EphemeralMcpServer:\n        \"\"\"\n        Create a job that will run until explicitly terminated.\n\n        This also creates a dedicated ServiceAccount with RBAC permissions for the spawned pod.\n\n        Args:\n            config: The configuration for the MCP servers\n\n        Returns:\n            The MCP server instance\n        \"\"\"\n        # Create ServiceAccount and RBAC resources for the job\n        service_account_name = create_service_account_for_job(\n            core_v1=self._core_v1,\n            rbac_v1=self._rbac_v1,\n            job_name=config.job_name,\n            namespace=self.namespace,\n            sa_config=config.sa_config,\n        )\n\n        # Create the job with the service account\n        job = create_mcp_server_job(config=config, namespace=self.namespace, service_account_name=service_account_name)\n        response = self._batch_v1.create_namespaced_job(namespace=self.namespace, body=job)\n        logger.info(f\"Job '{config.job_name}' created successfully\")\n        logger.debug(f\"Job response: {response}\")\n        if not response.metadata or not response.metadata.name:\n            raise MCPServerCreationError(str(response.metadata))\n        return EphemeralMcpServer(config=config, job_name=response.metadata.name)\n\n    async def _get_job_status(self, job_name: str) -&gt; None | client.V1Job:\n        \"\"\"\n        Get current status of a job.\n\n        Args:\n            job_name: Name of the pod\n\n        Returns:\n            The job status\n        \"\"\"\n        return get_mcp_server_job_status(self._batch_v1, job_name, self.namespace)\n\n    async def _check_pod_status(self, job_name: str) -&gt; bool:\n        \"\"\"\n        Check the status of pods associated with a job.\n\n        Args:\n            job_name: Name of the job/pod\n\n        Returns:\n            True if a pod is running and ready (probes successful), False if waiting for pods\n\n        Raises:\n            MCPJobError: If a pod is in Failed or Unknown state\n        \"\"\"\n        return check_pod_status(self._core_v1, job_name, self.namespace)\n\n    async def _wait_for_job_ready(self, job_name: str) -&gt; None:\n        \"\"\"Wait for a job's pod to be in the running state and ready (probes successful).\n\n        Args:\n            job_name: Name of the job/pod\n        \"\"\"\n        await wait_for_job_ready(\n            self._batch_v1, self._core_v1, job_name, self.namespace, self.sleep_time, self.max_wait_time\n        )\n\n    async def _wait_for_job_deletion(self, job_name: str) -&gt; None:\n        \"\"\"Wait for a job to be deleted.\n\n        Args:\n            job_name: Name of the job/pod\n        \"\"\"\n        await wait_for_job_deletion(self._batch_v1, job_name, self.namespace, self.sleep_time, self.max_wait_time)\n\n    async def _delete_job(self, job_name: str) -&gt; bool:\n        \"\"\"\n        Delete a Kubernetes job and its associated pods.\n\n        This also deletes the dedicated ServiceAccount and RBAC resources.\n\n        Args:\n            job_name: Name of the job/pod\n\n        Returns:\n            True if the job was deleted successfully, False otherwise\n        \"\"\"\n        # Remove service port if it exists\n        if job_name in self.jobs:\n            try:\n                self.remove_mcp_server_port(self.jobs[job_name])\n            except Exception as e:\n                logger.warning(f\"Failed to remove MCP server port for job {job_name}: {e}\")\n        else:\n            logger.warning(f\"Job {job_name} not found in session manager, skipping port removal\")\n\n        # Delete the job and pods\n        job_deleted = delete_mcp_server_job(self._core_v1, self._batch_v1, job_name, self.namespace)\n\n        # Delete ServiceAccount and RBAC resources\n        if job_name in self.jobs:\n            job_config = self.jobs[job_name].config\n            cluster_wide = job_config.sa_config.cluster_wide if job_config.sa_config else True\n        else:\n            # Default to cluster_wide=True if job not found in tracking\n            cluster_wide = True\n            logger.warning(f\"Job {job_name} config not found, using default cluster_wide=True for RBAC cleanup\")\n\n        rbac_deleted = delete_service_account_for_job(\n            core_v1=self._core_v1,\n            rbac_v1=self._rbac_v1,\n            job_name=job_name,\n            namespace=self.namespace,\n            cluster_wide=cluster_wide,\n        )\n\n        return job_deleted and rbac_deleted\n\n    async def create_mcp_server(\n        self, config: EphemeralMcpServerConfig, wait_for_ready: bool = True, expose_port: bool = False\n    ) -&gt; EphemeralMcpServer:\n        \"\"\"Start a new MCP server using the provided configuration.\n\n        Args:\n            config: The configuration for the MCP servers\n            wait_for_ready: Whether to wait for the job to be ready before returning a response to the client\n            expose_port: Whether to expose the port through a Kubernetes service\n\n        Returns:\n            The MCP server instance\n        \"\"\"\n        mcp_server = await self._create_job(config)\n        self.jobs[mcp_server.job_name] = mcp_server\n        if wait_for_ready:\n            await self._wait_for_job_ready(mcp_server.job_name)\n            logger.info(f\"MCP server {mcp_server.job_name} ready\")\n        if expose_port:\n            self.expose_mcp_server_port(mcp_server)\n            logger.info(f\"MCP server {mcp_server.job_name} port exposed with service '{mcp_server.job_name}'\")\n        return mcp_server\n\n    async def delete_mcp_server(self, job_name: str, wait_for_deletion: bool = True) -&gt; EphemeralMcpServer:\n        \"\"\"Delete the MCP server.\n\n        Args:\n            job_name: Name of the job/pod\n            wait_for_deletion: Whether to wait for the job to be deleted\n\n        Returns:\n            The MCP server instance\n        \"\"\"\n        if job_name in self.jobs:\n            await self._delete_job(job_name)\n            if wait_for_deletion:\n                await self._wait_for_job_deletion(job_name)\n            config = self.jobs[job_name].config\n            result = EphemeralMcpServer(config=config, job_name=job_name)\n            del self.jobs[job_name]\n            return result\n        raise MCPJobNotFoundError(self.namespace, job_name)\n\n    def expose_mcp_server_port(self, mcp_server: EphemeralMcpServer) -&gt; None:\n        \"\"\"Expose the MCP server port to the outside world through a Kubernetes service.\"\"\"\n        expose_mcp_server_port(self._core_v1, mcp_server.job_name, self.namespace, mcp_server.config.port)\n\n    def remove_mcp_server_port(self, mcp_server: EphemeralMcpServer) -&gt; None:\n        \"\"\"Remove the MCP server.\"\"\"\n        remove_mcp_server_port(self._core_v1, mcp_server.job_name, self.namespace)\n\n    async def mount_mcp_server(self, job_name: str) -&gt; tuple[FastMCP, EphemeralMcpServer]:\n        \"\"\"Mount an MCP server over SSE.\n\n        Args:\n            job_name: The name of the pod that is running the MCP server.\n        \"\"\"\n        if job_name not in self.jobs:\n            raise MCPJobNotFoundError(self.namespace, job_name)\n        mcp_server = self.jobs[job_name]\n        url = str(mcp_server.sse_url)\n        if self.runtime == KubernetesRuntime.KUBECONFIG:\n            # @TODO we need to port forward when running locally\n            url = f\"http://localhost:{mcp_server.config.port}/sse\"\n            logger.warning(\n                f\"The MCP server is running locally, port forwarding to localhost is required if you want to access {url=!r} for {job_name=!r}\"\n            )\n        else:\n            # we are running in a cluster\n            url = str(mcp_server.sse_url)\n        server = create_proxy_server(url=url)\n        logger.info(f\"Mounted MCP server {mcp_server.job_name} over SSE\")\n        return server, mcp_server\n</code></pre>"},{"location":"modules/#mcp_ephemeral_k8s.session_manager.KubernetesSessionManager.__aenter__","title":"<code>__aenter__()</code>  <code>async</code>","text":"<p>Enter the async context manager.</p> Source code in <code>src/mcp_ephemeral_k8s/session_manager.py</code> <pre><code>async def __aenter__(self) -&gt; Self:\n    \"\"\"Enter the async context manager.\"\"\"\n    self.load_session_manager()\n    return self\n</code></pre>"},{"location":"modules/#mcp_ephemeral_k8s.session_manager.KubernetesSessionManager.__aexit__","title":"<code>__aexit__(exc_type, exc_val, exc_tb)</code>  <code>async</code>","text":"<p>Exit the async context manager.</p> Source code in <code>src/mcp_ephemeral_k8s/session_manager.py</code> <pre><code>async def __aexit__(self, exc_type: Any, exc_val: Any, exc_tb: Any) -&gt; None:\n    \"\"\"Exit the async context manager.\"\"\"\n    for job_name in self.jobs:\n        await self._delete_job(job_name)\n</code></pre>"},{"location":"modules/#mcp_ephemeral_k8s.session_manager.KubernetesSessionManager.create_mcp_server","title":"<code>create_mcp_server(config, wait_for_ready=True, expose_port=False)</code>  <code>async</code>","text":"<p>Start a new MCP server using the provided configuration.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>EphemeralMcpServerConfig</code> <p>The configuration for the MCP servers</p> required <code>wait_for_ready</code> <code>bool</code> <p>Whether to wait for the job to be ready before returning a response to the client</p> <code>True</code> <code>expose_port</code> <code>bool</code> <p>Whether to expose the port through a Kubernetes service</p> <code>False</code> <p>Returns:</p> Type Description <code>EphemeralMcpServer</code> <p>The MCP server instance</p> Source code in <code>src/mcp_ephemeral_k8s/session_manager.py</code> <pre><code>async def create_mcp_server(\n    self, config: EphemeralMcpServerConfig, wait_for_ready: bool = True, expose_port: bool = False\n) -&gt; EphemeralMcpServer:\n    \"\"\"Start a new MCP server using the provided configuration.\n\n    Args:\n        config: The configuration for the MCP servers\n        wait_for_ready: Whether to wait for the job to be ready before returning a response to the client\n        expose_port: Whether to expose the port through a Kubernetes service\n\n    Returns:\n        The MCP server instance\n    \"\"\"\n    mcp_server = await self._create_job(config)\n    self.jobs[mcp_server.job_name] = mcp_server\n    if wait_for_ready:\n        await self._wait_for_job_ready(mcp_server.job_name)\n        logger.info(f\"MCP server {mcp_server.job_name} ready\")\n    if expose_port:\n        self.expose_mcp_server_port(mcp_server)\n        logger.info(f\"MCP server {mcp_server.job_name} port exposed with service '{mcp_server.job_name}'\")\n    return mcp_server\n</code></pre>"},{"location":"modules/#mcp_ephemeral_k8s.session_manager.KubernetesSessionManager.delete_mcp_server","title":"<code>delete_mcp_server(job_name, wait_for_deletion=True)</code>  <code>async</code>","text":"<p>Delete the MCP server.</p> <p>Parameters:</p> Name Type Description Default <code>job_name</code> <code>str</code> <p>Name of the job/pod</p> required <code>wait_for_deletion</code> <code>bool</code> <p>Whether to wait for the job to be deleted</p> <code>True</code> <p>Returns:</p> Type Description <code>EphemeralMcpServer</code> <p>The MCP server instance</p> Source code in <code>src/mcp_ephemeral_k8s/session_manager.py</code> <pre><code>async def delete_mcp_server(self, job_name: str, wait_for_deletion: bool = True) -&gt; EphemeralMcpServer:\n    \"\"\"Delete the MCP server.\n\n    Args:\n        job_name: Name of the job/pod\n        wait_for_deletion: Whether to wait for the job to be deleted\n\n    Returns:\n        The MCP server instance\n    \"\"\"\n    if job_name in self.jobs:\n        await self._delete_job(job_name)\n        if wait_for_deletion:\n            await self._wait_for_job_deletion(job_name)\n        config = self.jobs[job_name].config\n        result = EphemeralMcpServer(config=config, job_name=job_name)\n        del self.jobs[job_name]\n        return result\n    raise MCPJobNotFoundError(self.namespace, job_name)\n</code></pre>"},{"location":"modules/#mcp_ephemeral_k8s.session_manager.KubernetesSessionManager.expose_mcp_server_port","title":"<code>expose_mcp_server_port(mcp_server)</code>","text":"<p>Expose the MCP server port to the outside world through a Kubernetes service.</p> Source code in <code>src/mcp_ephemeral_k8s/session_manager.py</code> <pre><code>def expose_mcp_server_port(self, mcp_server: EphemeralMcpServer) -&gt; None:\n    \"\"\"Expose the MCP server port to the outside world through a Kubernetes service.\"\"\"\n    expose_mcp_server_port(self._core_v1, mcp_server.job_name, self.namespace, mcp_server.config.port)\n</code></pre>"},{"location":"modules/#mcp_ephemeral_k8s.session_manager.KubernetesSessionManager.load_session_manager","title":"<code>load_session_manager()</code>","text":"<p>Load Kubernetes configuration from default location or from service account if running in cluster.</p> Source code in <code>src/mcp_ephemeral_k8s/session_manager.py</code> <pre><code>def load_session_manager(self) -&gt; Self:\n    \"\"\"Load Kubernetes configuration from default location or from service account if running in cluster.\"\"\"\n    self._load_kube_config()\n    if not hasattr(self, \"_api_client\"):\n        self._api_client = ApiClient()\n    if not hasattr(self, \"_batch_v1\"):\n        self._batch_v1 = BatchV1Api(self._api_client)\n    if not hasattr(self, \"_core_v1\"):\n        self._core_v1 = CoreV1Api(self._api_client)\n    if not hasattr(self, \"_rbac_v1\"):\n        self._rbac_v1 = RbacAuthorizationV1Api(self._api_client)\n    # Check if the configured namespace exists using direct read (more efficient than listing all)\n    try:\n        self._core_v1.read_namespace(name=self.namespace)\n    except Exception as e:\n        raise MCPNamespaceNotFoundError(self.namespace) from e\n    return self\n</code></pre>"},{"location":"modules/#mcp_ephemeral_k8s.session_manager.KubernetesSessionManager.mount_mcp_server","title":"<code>mount_mcp_server(job_name)</code>  <code>async</code>","text":"<p>Mount an MCP server over SSE.</p> <p>Parameters:</p> Name Type Description Default <code>job_name</code> <code>str</code> <p>The name of the pod that is running the MCP server.</p> required Source code in <code>src/mcp_ephemeral_k8s/session_manager.py</code> <pre><code>async def mount_mcp_server(self, job_name: str) -&gt; tuple[FastMCP, EphemeralMcpServer]:\n    \"\"\"Mount an MCP server over SSE.\n\n    Args:\n        job_name: The name of the pod that is running the MCP server.\n    \"\"\"\n    if job_name not in self.jobs:\n        raise MCPJobNotFoundError(self.namespace, job_name)\n    mcp_server = self.jobs[job_name]\n    url = str(mcp_server.sse_url)\n    if self.runtime == KubernetesRuntime.KUBECONFIG:\n        # @TODO we need to port forward when running locally\n        url = f\"http://localhost:{mcp_server.config.port}/sse\"\n        logger.warning(\n            f\"The MCP server is running locally, port forwarding to localhost is required if you want to access {url=!r} for {job_name=!r}\"\n        )\n    else:\n        # we are running in a cluster\n        url = str(mcp_server.sse_url)\n    server = create_proxy_server(url=url)\n    logger.info(f\"Mounted MCP server {mcp_server.job_name} over SSE\")\n    return server, mcp_server\n</code></pre>"},{"location":"modules/#mcp_ephemeral_k8s.session_manager.KubernetesSessionManager.remove_mcp_server_port","title":"<code>remove_mcp_server_port(mcp_server)</code>","text":"<p>Remove the MCP server.</p> Source code in <code>src/mcp_ephemeral_k8s/session_manager.py</code> <pre><code>def remove_mcp_server_port(self, mcp_server: EphemeralMcpServer) -&gt; None:\n    \"\"\"Remove the MCP server.\"\"\"\n    remove_mcp_server_port(self._core_v1, mcp_server.job_name, self.namespace)\n</code></pre>"},{"location":"modules/#command-line-interface","title":"Command Line Interface","text":""},{"location":"modules/#mcp_ephemeral_k8s.cli.McpEphemeralK8s","title":"<code>McpEphemeralK8s</code>","text":"<p>               Bases: <code>BaseSettings</code></p> <p>The MCP ephemeral K8s CLI.</p> Source code in <code>src/mcp_ephemeral_k8s/cli.py</code> <pre><code>class McpEphemeralK8s(BaseSettings):\n    \"\"\"The MCP ephemeral K8s CLI.\"\"\"\n\n    model_config = SettingsConfigDict(cli_kebab_case=True)\n    init: CliSubCommand[Init] = Field(description=\"Initialize the MCP ephemeral K8s client in the current directory\")\n    serve: CliSubCommand[Serve] = Field(description=\"Serve the MCP ephemeral K8s client\")\n\n    def cli_cmd(self) -&gt; None:\n        CliApp.run_subcommand(self)\n</code></pre>"},{"location":"modules/#application-layer","title":"Application Layer","text":"<p>MCP server application, meant to be used as an MCP server that can spawn other MCP servers.</p>"},{"location":"modules/#mcp_ephemeral_k8s.app.mcp_server.create_mcp_server","title":"<code>create_mcp_server(ctx, runtime_exec, runtime_mcp, runtime_args='', env=None, wait_for_ready=False)</code>  <code>async</code>","text":"<p>Create a new ephemeral MCP server in Kubernetes.</p> <p>Spawns a new MCP server instance as a Kubernetes Job with the specified configuration. The server runs in an isolated environment and can be customized with different runtime executors, packages, arguments, and environment variables.</p> <p>Parameters:</p> Name Type Description Default <code>runtime_exec</code> <code>str</code> <p>The executor to use for running the MCP server (e.g., 'uvx' for Python packages, 'npx' for Node.js packages, 'docker' for container images).</p> required <code>runtime_mcp</code> <code>str</code> <p>The MCP package or image to run (e.g., 'mcp-server-sqlite' for a Python-based SQLite MCP server, or '@modelcontextprotocol/server-filesystem' for a Node.js filesystem server).</p> required <code>runtime_args</code> <code>str</code> <p>Optional arguments to pass to the MCP server at runtime. These are appended to the command line when starting the server.</p> <code>''</code> <code>env</code> <code>dict[str, str] | None</code> <p>Optional dictionary of environment variables to set in the server's container. Useful for configuration, authentication tokens, or feature flags.</p> <code>None</code> <code>wait_for_ready</code> <code>bool</code> <p>If True, this call will block until the Kubernetes Job is in a ready state. If False, returns immediately after submitting the Job.</p> <code>False</code> <p>Returns:</p> Type Description <code>EphemeralMcpServer</code> <p>An EphemeralMcpServer object containing the created server's configuration,</p> <code>EphemeralMcpServer</code> <p>pod name, status, and connection details.</p> Example usage <p>To create a filesystem MCP server: create_mcp_server(     runtime_exec='npx',     runtime_mcp='@modelcontextprotocol/server-filesystem',     runtime_args='/tmp',     wait_for_ready=True )</p> Source code in <code>src/mcp_ephemeral_k8s/app/mcp_server.py</code> <pre><code>@mcp.tool(\"create_mcp_server\")\nasync def create_mcp_server(\n    ctx: Context,\n    runtime_exec: str,\n    runtime_mcp: str,\n    runtime_args: str = \"\",\n    env: dict[str, str] | None = None,\n    wait_for_ready: bool = False,\n) -&gt; EphemeralMcpServer:\n    \"\"\"\n    Create a new ephemeral MCP server in Kubernetes.\n\n    Spawns a new MCP server instance as a Kubernetes Job with the specified configuration.\n    The server runs in an isolated environment and can be customized with different\n    runtime executors, packages, arguments, and environment variables.\n\n    Args:\n        runtime_exec: The executor to use for running the MCP server (e.g., 'uvx' for\n            Python packages, 'npx' for Node.js packages, 'docker' for container images).\n        runtime_mcp: The MCP package or image to run (e.g., 'mcp-server-sqlite' for a\n            Python-based SQLite MCP server, or '@modelcontextprotocol/server-filesystem'\n            for a Node.js filesystem server).\n        runtime_args: Optional arguments to pass to the MCP server at runtime. These are\n            appended to the command line when starting the server.\n        env: Optional dictionary of environment variables to set in the server's container.\n            Useful for configuration, authentication tokens, or feature flags.\n        wait_for_ready: If True, this call will block until the Kubernetes Job is in a\n            ready state. If False, returns immediately after submitting the Job.\n\n    Returns:\n        An EphemeralMcpServer object containing the created server's configuration,\n        pod name, status, and connection details.\n\n    Example usage:\n        To create a filesystem MCP server: create_mcp_server(\n            runtime_exec='npx',\n            runtime_mcp='@modelcontextprotocol/server-filesystem',\n            runtime_args='/tmp',\n            wait_for_ready=True\n        )\n    \"\"\"\n    config = EphemeralMcpServerConfig(\n        runtime_exec=runtime_exec,\n        runtime_mcp=runtime_mcp,\n        runtime_args=runtime_args,\n        env=env,\n    )\n    session_manager: KubernetesSessionManager = ctx.request_context.lifespan_context\n    return await session_manager.create_mcp_server(config, wait_for_ready=wait_for_ready, expose_port=True)\n</code></pre>"},{"location":"modules/#mcp_ephemeral_k8s.app.mcp_server.delete_mcp_server","title":"<code>delete_mcp_server(ctx, job_name, wait_for_deletion=False)</code>  <code>async</code>","text":"<p>Delete an ephemeral MCP server and clean up its resources.</p> <p>Terminates a running MCP server instance and removes its associated Kubernetes resources including the Job, Pod, and any exposed Services. This is important for cleaning up resources when an MCP server is no longer needed.</p> <p>Parameters:</p> Name Type Description Default <code>job_name</code> <code>str</code> <p>The name of the pod/server to delete. This is returned when creating a server and can be retrieved using list_mcp_servers().</p> required <code>wait_for_deletion</code> <code>bool</code> <p>If True, this call will block until the Kubernetes resources are fully deleted and removed from the cluster. If False, initiates deletion and returns immediately.</p> <code>False</code> <p>Returns:</p> Type Description <code>EphemeralMcpServer</code> <p>An EphemeralMcpServer object containing the deleted server's final state and</p> <code>EphemeralMcpServer</code> <p>metadata before removal.</p> Example usage <p>After retrieving the list of servers, delete a specific one by its pod name: delete_mcp_server(job_name='mcp-server-xyz123', wait_for_deletion=True)</p> Source code in <code>src/mcp_ephemeral_k8s/app/mcp_server.py</code> <pre><code>@mcp.tool(\"delete_mcp_server\")\nasync def delete_mcp_server(ctx: Context, job_name: str, wait_for_deletion: bool = False) -&gt; EphemeralMcpServer:\n    \"\"\"\n    Delete an ephemeral MCP server and clean up its resources.\n\n    Terminates a running MCP server instance and removes its associated Kubernetes\n    resources including the Job, Pod, and any exposed Services. This is important\n    for cleaning up resources when an MCP server is no longer needed.\n\n    Args:\n        job_name: The name of the pod/server to delete. This is returned when creating\n            a server and can be retrieved using list_mcp_servers().\n        wait_for_deletion: If True, this call will block until the Kubernetes resources\n            are fully deleted and removed from the cluster. If False, initiates deletion\n            and returns immediately.\n\n    Returns:\n        An EphemeralMcpServer object containing the deleted server's final state and\n        metadata before removal.\n\n    Example usage:\n        After retrieving the list of servers, delete a specific one by its pod name:\n        delete_mcp_server(job_name='mcp-server-xyz123', wait_for_deletion=True)\n    \"\"\"\n    session_manager: KubernetesSessionManager = ctx.request_context.lifespan_context\n    return await session_manager.delete_mcp_server(job_name, wait_for_deletion=wait_for_deletion)\n</code></pre>"},{"location":"modules/#mcp_ephemeral_k8s.app.mcp_server.get_mcp_server_status","title":"<code>get_mcp_server_status(ctx, job_name)</code>  <code>async</code>","text":"<p>Get the detailed Kubernetes status of an MCP server.</p> <p>Retrieves the underlying Kubernetes Job status for a specific MCP server instance. This provides low-level details about the Job's execution state, including conditions, start/completion times, and any failure information.</p> <p>Parameters:</p> Name Type Description Default <code>job_name</code> <code>str</code> <p>The name of the pod/server to check. This identifier is returned when creating a server and can be retrieved using list_mcp_servers().</p> required <p>Returns:</p> Type Description <code>V1Job | None</code> <p>A Kubernetes V1Job object containing the Job's complete status information,</p> <code>V1Job | None</code> <p>or None if the Job is not found. The Job status includes fields such as:</p> <code>V1Job | None</code> <ul> <li>active: number of active pods</li> </ul> <code>V1Job | None</code> <ul> <li>succeeded: number of succeeded pods</li> </ul> <code>V1Job | None</code> <ul> <li>failed: number of failed pods</li> </ul> <code>V1Job | None</code> <ul> <li>conditions: detailed state information</li> </ul> <code>V1Job | None</code> <ul> <li>start_time and completion_time</li> </ul> Example usage <p>Use this to debug issues with a server or to check if a Job has completed successfully: get_mcp_server_status(job_name='mcp-server-xyz123')</p> Source code in <code>src/mcp_ephemeral_k8s/app/mcp_server.py</code> <pre><code>@mcp.tool(\"get_mcp_server_status\")\nasync def get_mcp_server_status(ctx: Context, job_name: str) -&gt; client.V1Job | None:\n    \"\"\"\n    Get the detailed Kubernetes status of an MCP server.\n\n    Retrieves the underlying Kubernetes Job status for a specific MCP server instance.\n    This provides low-level details about the Job's execution state, including\n    conditions, start/completion times, and any failure information.\n\n    Args:\n        job_name: The name of the pod/server to check. This identifier is returned\n            when creating a server and can be retrieved using list_mcp_servers().\n\n    Returns:\n        A Kubernetes V1Job object containing the Job's complete status information,\n        or None if the Job is not found. The Job status includes fields such as:\n        - active: number of active pods\n        - succeeded: number of succeeded pods\n        - failed: number of failed pods\n        - conditions: detailed state information\n        - start_time and completion_time\n\n    Example usage:\n        Use this to debug issues with a server or to check if a Job has completed\n        successfully: get_mcp_server_status(job_name='mcp-server-xyz123')\n    \"\"\"\n    session_manager: KubernetesSessionManager = ctx.request_context.lifespan_context\n    return await session_manager._get_job_status(job_name)\n</code></pre>"},{"location":"modules/#mcp_ephemeral_k8s.app.mcp_server.get_version","title":"<code>get_version()</code>","text":"<p>Get the version of the MCP ephemeral server.</p> Source code in <code>src/mcp_ephemeral_k8s/app/mcp_server.py</code> <pre><code>@mcp.resource(\"config://version\")\ndef get_version() -&gt; str:\n    \"\"\"Get the version of the MCP ephemeral server.\"\"\"\n    return __version__\n</code></pre>"},{"location":"modules/#mcp_ephemeral_k8s.app.mcp_server.health_check","title":"<code>health_check(request)</code>  <code>async</code>","text":"<p>Health check endpoint for the MCP server.</p> Source code in <code>src/mcp_ephemeral_k8s/app/mcp_server.py</code> <pre><code>@mcp.custom_route(\"/health\", methods=[\"GET\"])\nasync def health_check(request: Request) -&gt; PlainTextResponse:\n    \"\"\"Health check endpoint for the MCP server.\"\"\"\n    return PlainTextResponse(\"OK\", status_code=200)\n</code></pre>"},{"location":"modules/#mcp_ephemeral_k8s.app.mcp_server.lifespan","title":"<code>lifespan(server)</code>  <code>async</code>","text":"<p>Lifecycle hooks for the MCP ephemeral server.</p> Source code in <code>src/mcp_ephemeral_k8s/app/mcp_server.py</code> <pre><code>@asynccontextmanager\nasync def lifespan(server: FastMCP) -&gt; AsyncIterator[KubernetesSessionManager]:\n    \"\"\"\n    Lifecycle hooks for the MCP ephemeral server.\n    \"\"\"\n    async with KubernetesSessionManager(\n        namespace=\"default\", jobs={}, sleep_time=1, max_wait_time=60\n    ) as session_manager:\n        yield session_manager\n</code></pre>"},{"location":"modules/#mcp_ephemeral_k8s.app.mcp_server.list_mcp_servers","title":"<code>list_mcp_servers(ctx)</code>  <code>async</code>","text":"<p>List all currently running ephemeral MCP servers.</p> <p>Retrieves information about all MCP server instances that are currently managed by this controller. Each server entry includes its pod name, configuration details, current status, creation timestamp, and connection information if available.</p> <p>Returns:</p> Type Description <code>list[EphemeralMcpServer]</code> <p>A list of EphemeralMcpServer objects representing all active MCP servers.</p> <code>list[EphemeralMcpServer]</code> <p>Each object contains the server's configuration, runtime status, and metadata.</p> Example usage <p>Call this tool to see what MCP servers are currently running before creating new ones or to check the status of existing servers.</p> Source code in <code>src/mcp_ephemeral_k8s/app/mcp_server.py</code> <pre><code>@mcp.tool(\"list_mcp_servers\")\nasync def list_mcp_servers(ctx: Context) -&gt; list[EphemeralMcpServer]:\n    \"\"\"\n    List all currently running ephemeral MCP servers.\n\n    Retrieves information about all MCP server instances that are currently managed\n    by this controller. Each server entry includes its pod name, configuration details,\n    current status, creation timestamp, and connection information if available.\n\n    Returns:\n        A list of EphemeralMcpServer objects representing all active MCP servers.\n        Each object contains the server's configuration, runtime status, and metadata.\n\n    Example usage:\n        Call this tool to see what MCP servers are currently running before creating\n        new ones or to check the status of existing servers.\n    \"\"\"\n    session_manager: KubernetesSessionManager = ctx.request_context.lifespan_context\n    return list(session_manager.jobs.values())\n</code></pre>"},{"location":"modules/#mcp_ephemeral_k8s.app.mcp_server.list_presets","title":"<code>list_presets()</code>","text":"<p>List all available preset MCP server configurations.</p> <p>Returns a list of pre-configured MCP server templates that can be used as examples or starting points for creating new ephemeral MCP servers. Each preset includes the runtime executor (e.g., 'uvx', 'npx'), the MCP package to install, optional runtime arguments, and environment variables.</p> <p>Returns:</p> Type Description <code>list[EphemeralMcpServerConfig]</code> <p>A list of EphemeralMcpServerConfig objects containing preset configurations.</p> <code>list[EphemeralMcpServerConfig]</code> <p>Each config specifies how to run a specific MCP server package.</p> Example usage <p>Use this to discover available MCP server configurations before creating one.</p> Source code in <code>src/mcp_ephemeral_k8s/app/mcp_server.py</code> <pre><code>@mcp.tool(\"list_presets\")\ndef list_presets() -&gt; list[EphemeralMcpServerConfig]:\n    \"\"\"\n    List all available preset MCP server configurations.\n\n    Returns a list of pre-configured MCP server templates that can be used as examples\n    or starting points for creating new ephemeral MCP servers. Each preset includes\n    the runtime executor (e.g., 'uvx', 'npx'), the MCP package to install, optional\n    runtime arguments, and environment variables.\n\n    Returns:\n        A list of EphemeralMcpServerConfig objects containing preset configurations.\n        Each config specifies how to run a specific MCP server package.\n\n    Example usage:\n        Use this to discover available MCP server configurations before creating one.\n    \"\"\"\n    return presets.EXAMPLE_MCP_SERVER_CONFIGS\n</code></pre>"},{"location":"modules/#mcp_ephemeral_k8s.app.mcp_server.main","title":"<code>main(transport='sse', show_banner=True, allow_origins=None, **transport_kwargs)</code>","text":"<p>Run the FastMCP server.</p> Source code in <code>src/mcp_ephemeral_k8s/app/mcp_server.py</code> <pre><code>def main(\n    transport: Transport = \"sse\",\n    show_banner: bool = True,\n    allow_origins: list[str] | None = None,\n    **transport_kwargs: Any,\n) -&gt; None:\n    \"\"\"Run the FastMCP server.\"\"\"\n    # Configure CORS middleware for SSE transport to support browser-based clients\n    if transport == \"sse\":\n        cors_middleware = [\n            (\n                CORSMiddleware,\n                (),\n                {\n                    \"allow_origins\": allow_origins or [\"*\"],\n                    \"allow_credentials\": True,\n                    \"allow_methods\": [\"*\"],\n                    \"allow_headers\": [\"*\"],\n                },\n            )\n        ]\n        transport_kwargs.setdefault(\"middleware\", cors_middleware)\n\n    mcp.run(transport=transport, show_banner=show_banner, **transport_kwargs)\n</code></pre>"},{"location":"modules/#mcp_ephemeral_k8s.app.mcp_server.mount_mcp_server","title":"<code>mount_mcp_server(ctx, job_name, name=None)</code>  <code>async</code>","text":"<p>Mount a remote MCP server over SSE.</p> <p>Parameters:</p> Name Type Description Default <code>job_name</code> <code>str</code> <p>The name of the pod that is running the remote MCP server.</p> required <code>name</code> <code>str | None</code> <p>The name of the proxy server.</p> <code>None</code> Source code in <code>src/mcp_ephemeral_k8s/app/mcp_server.py</code> <pre><code>@mcp.tool(\"mount_mcp_server\")\nasync def mount_mcp_server(ctx: Context, job_name: str, name: str | None = None) -&gt; EphemeralMcpServer:\n    \"\"\"Mount a remote MCP server over SSE.\n\n    Args:\n        job_name: The name of the pod that is running the remote MCP server.\n        name: The name of the proxy server.\n    \"\"\"\n    session_manager: KubernetesSessionManager = ctx.request_context.lifespan_context\n    server, ephemeral_server = await session_manager.mount_mcp_server(job_name)\n    mcp.mount(server=server, prefix=name, as_proxy=True)\n    return ephemeral_server\n</code></pre>"},{"location":"modules/#mcp_ephemeral_k8s.app.mcp_server.remove_mcp_server_mount","title":"<code>remove_mcp_server_mount(name=None)</code>  <code>async</code>","text":"<p>Remove the mount of an MCP server.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str | None</code> <p>The name of the server to remove. If None, all mounted servers with a prefix will be removed.</p> <code>None</code> Source code in <code>src/mcp_ephemeral_k8s/app/mcp_server.py</code> <pre><code>@mcp.tool(\"remove_mcp_server_mount\")\nasync def remove_mcp_server_mount(name: str | None = None) -&gt; None:\n    \"\"\"Remove the mount of an MCP server.\n\n    Args:\n        name: The name of the server to remove. If None, all mounted servers with a prefix will be removed.\n    \"\"\"\n    # Collect servers to remove first to avoid index shifting issues\n    servers_to_remove = [\n        mounted_server\n        for mounted_server in mcp._mounted_servers\n        if mounted_server.prefix == name or (name is None and mounted_server.prefix is not None)\n    ]\n\n    if not servers_to_remove:\n        msg = f\"No mounted server found with name {name}\" if name is not None else \"No mounted servers found\"\n        raise ValueError(msg)\n\n    # Remove servers from the list\n    for server in servers_to_remove:\n        mcp._mounted_servers.remove(server)\n</code></pre>"},{"location":"modules/#api-models-configuration","title":"API Models &amp; Configuration","text":"<p>This module contains the models for the MCP ephemeral K8s library.</p>"},{"location":"modules/#mcp_ephemeral_k8s.api.ephemeral_mcp_server.EphemeralMcpServer","title":"<code>EphemeralMcpServer</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>The MCP server that is running in a Kubernetes pod.</p> Source code in <code>src/mcp_ephemeral_k8s/api/ephemeral_mcp_server.py</code> <pre><code>class EphemeralMcpServer(BaseModel):\n    \"\"\"The MCP server that is running in a Kubernetes pod.\"\"\"\n\n    job_name: str = Field(\n        description=\"The name of the pod that is running the MCP server\", examples=[\"mcp-ephemeral-k8s-proxy-test\"]\n    )\n    config: EphemeralMcpServerConfig = Field(\n        description=\"The configuration that was used to create the MCP server\",\n        examples=[\n            EphemeralMcpServerConfig(\n                runtime_exec=\"uvx\",\n                runtime_mcp=\"mcp-server-fetch\",\n                port=8000,\n                cors_origins=[\"*\"],\n            )\n        ],\n    )\n\n    @computed_field  # type: ignore[prop-decorator]\n    @property\n    def url(self) -&gt; HttpUrl:\n        \"\"\"The Uniform Resource Locator (URL) for the MCP server.\"\"\"\n        return HttpUrl(f\"http://{self.job_name}.default.svc.cluster.local:{self.config.port}/\")\n\n    @computed_field  # type: ignore[prop-decorator]\n    @property\n    def sse_url(self) -&gt; HttpUrl:\n        \"\"\"The Server-Sent Events (SSE) URL for the MCP server.\"\"\"\n        return HttpUrl(f\"{self.url}sse\")\n</code></pre>"},{"location":"modules/#mcp_ephemeral_k8s.api.ephemeral_mcp_server.EphemeralMcpServer.sse_url","title":"<code>sse_url</code>  <code>property</code>","text":"<p>The Server-Sent Events (SSE) URL for the MCP server.</p>"},{"location":"modules/#mcp_ephemeral_k8s.api.ephemeral_mcp_server.EphemeralMcpServer.url","title":"<code>url</code>  <code>property</code>","text":"<p>The Uniform Resource Locator (URL) for the MCP server.</p>"},{"location":"modules/#mcp_ephemeral_k8s.api.ephemeral_mcp_server.EphemeralMcpServerConfig","title":"<code>EphemeralMcpServerConfig</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Configuration for Kubernetes resources.</p> Source code in <code>src/mcp_ephemeral_k8s/api/ephemeral_mcp_server.py</code> <pre><code>class EphemeralMcpServerConfig(BaseModel):\n    \"\"\"Configuration for Kubernetes resources.\"\"\"\n\n    runtime_exec: str | None = Field(\n        description=\"The runtime to use for the MCP container. When None, the image is assumed to be a MCP server instead of a proxy.\",\n        examples=[\"uvx\", \"npx\"],\n    )\n    runtime_mcp: str | None = Field(\n        description=\"The runtime to use for the MCP container. Can be any supported MCP server runtime loadable via the `runtime_exec`. See the [MCP Server Runtimes](https://github.com/modelcontextprotocol/servers/tree/main) for a list of supported runtimes.\",\n        examples=[\"mcp-server-fetch\", \"@modelcontextprotocol/server-github\"],\n    )\n    runtime_args: str = Field(\n        default_factory=str,\n        description=\"The arguments to pass to the MCP server runtime.\",\n        examples=[\"--port 8080\"],\n    )\n    image: str = Field(\n        default=\"ghcr.io/bobmerkus/mcp-ephemeral-k8s-proxy:latest\",\n        description=\"The image to use for the MCP server proxy\",\n    )\n    entrypoint: list[str] | None = Field(\n        default=[\"mcp-proxy\"],\n        description=\"The entrypoint for the MCP container. Normally not changed unless a custom image is used.\",\n    )\n    host: str = Field(default=\"0.0.0.0\", description=\"The host to expose the MCP server on\")  # noqa: S104\n    port: int = Field(default=8080, description=\"The port to expose the MCP server on\")\n    resource_requests: dict[str, str] = Field(\n        default={\"cpu\": \"100m\", \"memory\": \"100Mi\"}, description=\"Resource requests for the container\"\n    )\n    resource_limits: dict[str, str] = Field(\n        default={\"cpu\": \"200m\", \"memory\": \"200Mi\"}, description=\"Resource limits for the container\"\n    )\n    env: dict[str, str] | None = Field(\n        default=None,\n        description=\"Environment variables to set for the container\",\n        examples=[None, {\"GITHUB_PERSONAL_ACCESS_TOKEN\": \"1234567890\", \"GITHUB_DYNAMIC_TOOLSETS\": \"1\"}],\n    )\n    cors_origins: list[str] | None = Field(\n        default=[\"*\"],\n        description=\"The origins to allow CORS from\",\n        examples=[\"*\"],\n    )\n    probe_config: KubernetesProbeConfig = Field(\n        default_factory=KubernetesProbeConfig,\n        description=\"The configuration for the Kubernetes probe\",\n    )\n    sa_config: ServiceAccountConfig | None = Field(\n        default=None,\n        description=\"ServiceAccount RBAC configuration. If None, uses minimal preset by default.\",\n    )\n\n    @model_validator(mode=\"after\")\n    def validate_runtime_exec(self) -&gt; Self:\n        \"\"\"Validate the runtime configuration.\n        Both runtime_exec and runtime_mcp must be specified, or neither.\n        \"\"\"\n        if self.runtime_exec is not None and self.runtime_mcp is None:\n            message = \"Invalid runtime: runtime_exec is specified but runtime_mcp is not\"\n            raise MCPInvalidRuntimeError(runtime_exec=self.runtime_exec, runtime_mcp=self.runtime_mcp, message=message)\n        if self.runtime_exec is None and self.runtime_mcp is not None:\n            message = \"Invalid runtime: runtime_mcp is specified but runtime_exec is not\"\n            raise MCPInvalidRuntimeError(runtime_exec=self.runtime_exec, runtime_mcp=self.runtime_mcp, message=message)\n        return self\n\n    @computed_field  # type: ignore[prop-decorator]\n    @property\n    def args(self) -&gt; list[str] | None:\n        \"\"\"The arguments to pass to the MCP server.\n        [mcp-proxy](https://github.com/sparfenyuk/mcp-proxy?tab=readme-ov-file#21-configuration)\"\"\"\n        if self.runtime_exec is not None and self.runtime_mcp is not None:\n            args = [\n                self.runtime_exec,\n                self.runtime_mcp,\n                \"--pass-environment\",\n                f\"--port={self.port}\",\n                f\"--host={self.host}\",\n            ]\n            if self.cors_origins is not None:\n                args.extend([\"--allow-origin\", *self.cors_origins])\n            if self.runtime_args:\n                args.append(f\"-- {self.runtime_args}\")\n            return args\n        return None\n\n    @computed_field  # type: ignore[prop-decorator]\n    @property\n    def image_name(self) -&gt; str:\n        \"\"\"The name of the image to use for the MCP server.\"\"\"\n        return self.image.split(\"/\")[-1].split(\":\")[0]\n\n    @computed_field  # type: ignore[prop-decorator]\n    @cached_property\n    def job_name(self) -&gt; str:\n        \"\"\"The name of the job to use for the MCP server.\"\"\"\n        return generate_unique_id(prefix=self.image_name)\n\n    @classmethod\n    def from_docker_image(cls, image: str, entrypoint: list[str] | None = None, **kwargs: Any) -&gt; Self:\n        \"\"\"Create an EphemeralMcpServerConfig from a Docker image.\n        The image must be a MCP server image, otherwise an error is raised.\n        \"\"\"\n        if image.startswith(\"ghcr.io/bobmerkus/mcp-ephemeral-k8s-proxy\") or image.startswith(\n            \"ghcr.io/sparfenyuk/mcp-proxy\"\n        ):\n            message = \"Invalid runtime: image is a proxy image, please use the `runtime_exec` and `runtime_mcp` fields to specify the MCP server to use.\"\n            raise MCPInvalidRuntimeError(runtime_exec=None, runtime_mcp=None, message=message)\n        return cls(image=image, entrypoint=entrypoint, runtime_exec=None, runtime_mcp=None, **kwargs)\n</code></pre>"},{"location":"modules/#mcp_ephemeral_k8s.api.ephemeral_mcp_server.EphemeralMcpServerConfig.args","title":"<code>args</code>  <code>property</code>","text":"<p>The arguments to pass to the MCP server. mcp-proxy</p>"},{"location":"modules/#mcp_ephemeral_k8s.api.ephemeral_mcp_server.EphemeralMcpServerConfig.image_name","title":"<code>image_name</code>  <code>property</code>","text":"<p>The name of the image to use for the MCP server.</p>"},{"location":"modules/#mcp_ephemeral_k8s.api.ephemeral_mcp_server.EphemeralMcpServerConfig.job_name","title":"<code>job_name</code>  <code>cached</code> <code>property</code>","text":"<p>The name of the job to use for the MCP server.</p>"},{"location":"modules/#mcp_ephemeral_k8s.api.ephemeral_mcp_server.EphemeralMcpServerConfig.from_docker_image","title":"<code>from_docker_image(image, entrypoint=None, **kwargs)</code>  <code>classmethod</code>","text":"<p>Create an EphemeralMcpServerConfig from a Docker image. The image must be a MCP server image, otherwise an error is raised.</p> Source code in <code>src/mcp_ephemeral_k8s/api/ephemeral_mcp_server.py</code> <pre><code>@classmethod\ndef from_docker_image(cls, image: str, entrypoint: list[str] | None = None, **kwargs: Any) -&gt; Self:\n    \"\"\"Create an EphemeralMcpServerConfig from a Docker image.\n    The image must be a MCP server image, otherwise an error is raised.\n    \"\"\"\n    if image.startswith(\"ghcr.io/bobmerkus/mcp-ephemeral-k8s-proxy\") or image.startswith(\n        \"ghcr.io/sparfenyuk/mcp-proxy\"\n    ):\n        message = \"Invalid runtime: image is a proxy image, please use the `runtime_exec` and `runtime_mcp` fields to specify the MCP server to use.\"\n        raise MCPInvalidRuntimeError(runtime_exec=None, runtime_mcp=None, message=message)\n    return cls(image=image, entrypoint=entrypoint, runtime_exec=None, runtime_mcp=None, **kwargs)\n</code></pre>"},{"location":"modules/#mcp_ephemeral_k8s.api.ephemeral_mcp_server.EphemeralMcpServerConfig.validate_runtime_exec","title":"<code>validate_runtime_exec()</code>","text":"<p>Validate the runtime configuration. Both runtime_exec and runtime_mcp must be specified, or neither.</p> Source code in <code>src/mcp_ephemeral_k8s/api/ephemeral_mcp_server.py</code> <pre><code>@model_validator(mode=\"after\")\ndef validate_runtime_exec(self) -&gt; Self:\n    \"\"\"Validate the runtime configuration.\n    Both runtime_exec and runtime_mcp must be specified, or neither.\n    \"\"\"\n    if self.runtime_exec is not None and self.runtime_mcp is None:\n        message = \"Invalid runtime: runtime_exec is specified but runtime_mcp is not\"\n        raise MCPInvalidRuntimeError(runtime_exec=self.runtime_exec, runtime_mcp=self.runtime_mcp, message=message)\n    if self.runtime_exec is None and self.runtime_mcp is not None:\n        message = \"Invalid runtime: runtime_mcp is specified but runtime_exec is not\"\n        raise MCPInvalidRuntimeError(runtime_exec=self.runtime_exec, runtime_mcp=self.runtime_mcp, message=message)\n    return self\n</code></pre>"},{"location":"modules/#mcp_ephemeral_k8s.api.ephemeral_mcp_server.KubernetesProbeConfig","title":"<code>KubernetesProbeConfig</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Configuration for Kubernetes readiness probe.</p> <p>The readiness probe is used to determine when a container is ready to accept traffic. These defaults are tuned for MCP server startup, which may take time to install dependencies.</p> <p>With defaults: waits 10s initially, then checks every 1s for up to 300 failures (5 minutes total).</p> Source code in <code>src/mcp_ephemeral_k8s/api/ephemeral_mcp_server.py</code> <pre><code>class KubernetesProbeConfig(BaseModel):\n    \"\"\"Configuration for Kubernetes readiness probe.\n\n    The readiness probe is used to determine when a container is ready to accept traffic.\n    These defaults are tuned for MCP server startup, which may take time to install dependencies.\n\n    With defaults: waits 10s initially, then checks every 1s for up to 300 failures (5 minutes total).\n    \"\"\"\n\n    initial_delay_seconds: int = Field(\n        default=10, description=\"Seconds to wait before performing the first probe (allows for container startup)\"\n    )\n    period_seconds: int = Field(default=1, description=\"How often (in seconds) to perform the probe\")\n    timeout_seconds: int = Field(default=2, description=\"Number of seconds after which the probe times out\")\n    success_threshold: int = Field(\n        default=1,\n        description=\"Minimum consecutive successes for the probe to be considered successful after having failed\",\n    )\n    failure_threshold: int = Field(\n        default=300,\n        description=\"Number of consecutive failures before giving up. With period_seconds=1, this allows 5 minutes for server startup\",\n    )\n</code></pre>"},{"location":"modules/#mcp_ephemeral_k8s.api.ephemeral_mcp_server.KubernetesRuntime","title":"<code>KubernetesRuntime</code>","text":"<p>               Bases: <code>StrEnum</code></p> <p>The runtime that is being used for Kubeconfig</p> Source code in <code>src/mcp_ephemeral_k8s/api/ephemeral_mcp_server.py</code> <pre><code>class KubernetesRuntime(StrEnum):\n    \"\"\"The runtime that is being used for Kubeconfig\"\"\"\n\n    KUBECONFIG = \"KUBECONFIG\"\n    INCLUSTER = \"INCLUSTER\"\n</code></pre>"},{"location":"modules/#exceptions","title":"Exceptions","text":"<p>This module contains the exceptions for the MCP ephemeral K8s library.</p>"},{"location":"modules/#mcp_ephemeral_k8s.api.exceptions.InvalidKubeConfigError","title":"<code>InvalidKubeConfigError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Exception raised when the kube config is invalid.</p> Source code in <code>src/mcp_ephemeral_k8s/api/exceptions.py</code> <pre><code>class InvalidKubeConfigError(Exception):\n    \"\"\"Exception raised when the kube config is invalid.\"\"\"\n\n    def __init__(self, message: str):\n        self.message = f\"Invalid kube config: {message}\"\n        super().__init__(self.message)\n</code></pre>"},{"location":"modules/#mcp_ephemeral_k8s.api.exceptions.MCPInvalidRuntimeError","title":"<code>MCPInvalidRuntimeError</code>","text":"<p>               Bases: <code>ValueError</code></p> <p>An error that occurs when the runtime is invalid.</p> Source code in <code>src/mcp_ephemeral_k8s/api/exceptions.py</code> <pre><code>class MCPInvalidRuntimeError(ValueError):\n    \"\"\"An error that occurs when the runtime is invalid.\"\"\"\n\n    def __init__(self, runtime_exec: str | None, runtime_mcp: str | None, message: str) -&gt; None:\n        super().__init__(f\"Invalid runtime: {runtime_exec=} and {runtime_mcp=} {message}\")\n</code></pre>"},{"location":"modules/#mcp_ephemeral_k8s.api.exceptions.MCPJobError","title":"<code>MCPJobError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Exception raised when the MCP job is in an error state.</p> Source code in <code>src/mcp_ephemeral_k8s/api/exceptions.py</code> <pre><code>class MCPJobError(Exception):\n    \"\"\"Exception raised when the MCP job is in an error state.\"\"\"\n\n    def __init__(self, namespace: str, job_name: str, message: str):\n        self.message = f\"MCP job error: {namespace=} {job_name=} - {message}\"\n        super().__init__(self.message)\n</code></pre>"},{"location":"modules/#mcp_ephemeral_k8s.api.exceptions.MCPJobNotFoundError","title":"<code>MCPJobNotFoundError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Exception raised when the MCP job is not found.</p> Source code in <code>src/mcp_ephemeral_k8s/api/exceptions.py</code> <pre><code>class MCPJobNotFoundError(Exception):\n    \"\"\"Exception raised when the MCP job is not found.\"\"\"\n\n    def __init__(self, namespace: str, job_name: str):\n        self.message = f\"Failed to find MCP job: {namespace=} {job_name=}\"\n        super().__init__(self.message)\n</code></pre>"},{"location":"modules/#mcp_ephemeral_k8s.api.exceptions.MCPJobTimeoutError","title":"<code>MCPJobTimeoutError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Exception raised when the MCP job times out.</p> Source code in <code>src/mcp_ephemeral_k8s/api/exceptions.py</code> <pre><code>class MCPJobTimeoutError(Exception):\n    \"\"\"Exception raised when the MCP job times out.\"\"\"\n\n    def __init__(self, namespace: str, job_name: str):\n        self.message = f\"MCP job timed out: {namespace=} {job_name=}\"\n        super().__init__(self.message)\n</code></pre>"},{"location":"modules/#mcp_ephemeral_k8s.api.exceptions.MCPNamespaceNotFoundError","title":"<code>MCPNamespaceNotFoundError</code>","text":"<p>               Bases: <code>ValueError</code></p> <p>An error that occurs when the namespace is not found.</p> Source code in <code>src/mcp_ephemeral_k8s/api/exceptions.py</code> <pre><code>class MCPNamespaceNotFoundError(ValueError):\n    \"\"\"An error that occurs when the namespace is not found.\"\"\"\n\n    def __init__(self, namespace: str):\n        self.message = f\"Namespace not found: {namespace}\"\n        super().__init__(self.message)\n</code></pre>"},{"location":"modules/#mcp_ephemeral_k8s.api.exceptions.MCPPortForwardError","title":"<code>MCPPortForwardError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Exception raised when the MCP port forward fails.</p> Source code in <code>src/mcp_ephemeral_k8s/api/exceptions.py</code> <pre><code>class MCPPortForwardError(Exception):\n    \"\"\"Exception raised when the MCP port forward fails.\"\"\"\n\n    def __init__(self, job_name: str, namespace: str, port: int):\n        self.message = f\"Failed to create port forward: {job_name=} {namespace=} {port=}\"\n        super().__init__(self.message)\n</code></pre>"},{"location":"modules/#mcp_ephemeral_k8s.api.exceptions.MCPServerCreationError","title":"<code>MCPServerCreationError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Exception raised when the MCP server creation fails.</p> Source code in <code>src/mcp_ephemeral_k8s/api/exceptions.py</code> <pre><code>class MCPServerCreationError(Exception):\n    \"\"\"Exception raised when the MCP server creation fails.\"\"\"\n\n    def __init__(self, message: str):\n        self.message = f\"Failed to create MCP server: {message}\"\n        super().__init__(self.message)\n</code></pre>"},{"location":"modules/#kubernetes-operations","title":"Kubernetes Operations","text":""},{"location":"modules/#job-management","title":"Job Management","text":""},{"location":"modules/#mcp_ephemeral_k8s.k8s.job.check_pod_status","title":"<code>check_pod_status(core_v1, job_name, namespace)</code>","text":"<p>Check the status of pods associated with a job.</p> <p>Parameters:</p> Name Type Description Default <code>core_v1</code> <code>CoreV1Api</code> <p>The Kubernetes core API client</p> required <code>job_name</code> <code>str</code> <p>Name of the job/pod</p> required <code>namespace</code> <code>str</code> <p>Kubernetes namespace</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if a pod is running and ready (probes successful), False if waiting for pods</p> <p>Raises:</p> Type Description <code>MCPJobError</code> <p>If a pod is in Failed or Unknown state</p> Source code in <code>src/mcp_ephemeral_k8s/k8s/job.py</code> <pre><code>def check_pod_status(core_v1: client.CoreV1Api, job_name: str, namespace: str) -&gt; bool:\n    \"\"\"\n    Check the status of pods associated with a job.\n\n    Args:\n        core_v1: The Kubernetes core API client\n        job_name: Name of the job/pod\n        namespace: Kubernetes namespace\n\n    Returns:\n        True if a pod is running and ready (probes successful), False if waiting for pods\n\n    Raises:\n        MCPJobError: If a pod is in Failed or Unknown state\n    \"\"\"\n    pods = core_v1.list_namespaced_pod(namespace=namespace, label_selector=f\"job-name={job_name}\")\n    if not pods.items:\n        logger.warning(f\"No pods found for job '{job_name}', waiting...\")\n        return False\n\n    for pod in pods.items:\n        if not pod.status or not pod.status.phase:\n            continue\n\n        # Handle error states\n        if pod.status.phase in [\"Failed\", \"Unknown\"]:\n            _handle_failed_pod(core_v1, pod, namespace, job_name)\n\n        # Handle running pods\n        if pod.status.phase == \"Running\":\n            if _is_pod_ready(pod):\n                logger.info(f\"Job '{job_name}' pod is running and ready (probes successful)\")\n                return True\n            else:\n                logger.info(f\"Job '{job_name}' pod is running but not ready yet (waiting for probes)\")\n\n    return False\n</code></pre>"},{"location":"modules/#mcp_ephemeral_k8s.k8s.job.create_mcp_server_job","title":"<code>create_mcp_server_job(config, namespace, service_account_name=None)</code>","text":"<p>Create a job that will run until explicitly terminated.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>EphemeralMcpServerConfig</code> <p>The configuration for the MCP server</p> required <code>namespace</code> <code>str</code> <p>Kubernetes namespace</p> required <code>service_account_name</code> <code>str | None</code> <p>Optional ServiceAccount name to use for the pod</p> <code>None</code> <p>Returns:</p> Type Description <code>V1Job</code> <p>The MCP server instance</p> Source code in <code>src/mcp_ephemeral_k8s/k8s/job.py</code> <pre><code>def create_mcp_server_job(\n    config: EphemeralMcpServerConfig, namespace: str, service_account_name: str | None = None\n) -&gt; client.V1Job:\n    \"\"\"\n    Create a job that will run until explicitly terminated.\n\n    Args:\n        config: The configuration for the MCP server\n        namespace: Kubernetes namespace\n        service_account_name: Optional ServiceAccount name to use for the pod\n\n    Returns:\n        The MCP server instance\n    \"\"\"\n    # Convert environment variables dictionary to list of V1EnvVar\n    env_list = [client.V1EnvVar(name=key, value=value) for key, value in (config.env or {}).items()]\n\n    # Configure the job\n    job = client.V1Job(\n        api_version=\"batch/v1\",\n        kind=\"Job\",\n        metadata=client.V1ObjectMeta(name=config.job_name, namespace=namespace),\n        spec=client.V1JobSpec(\n            backoff_limit=10,\n            template=client.V1PodTemplateSpec(\n                metadata=client.V1ObjectMeta(labels={\"app\": config.job_name}),\n                spec=client.V1PodSpec(\n                    service_account_name=service_account_name,\n                    containers=[\n                        client.V1Container(\n                            name=config.job_name,\n                            image=config.image,\n                            command=config.entrypoint,\n                            image_pull_policy=\"IfNotPresent\",\n                            args=config.args,\n                            resources=client.V1ResourceRequirements(\n                                requests=config.resource_requests, limits=config.resource_limits\n                            ),\n                            ports=[client.V1ContainerPort(container_port=config.port)],\n                            env=env_list,\n                            readiness_probe=client.V1Probe(\n                                tcp_socket=client.V1TCPSocketAction(port=config.port),\n                                **config.probe_config.model_dump(),\n                            ),\n                        )\n                    ],\n                    restart_policy=\"Never\",\n                ),\n            ),\n        ),\n    )\n\n    return job\n</code></pre>"},{"location":"modules/#mcp_ephemeral_k8s.k8s.job.create_proxy_server","title":"<code>create_proxy_server(url, **kwargs)</code>","text":"<p>Create a proxy server from a remote MCP server over SSE.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The SSE endpoint URL of the remote MCP server</p> required <code>**kwargs</code> <code>Any</code> <p>Additional keyword arguments for SSETransport configuration - sse_read_timeout: SSE read timeout (default: 300s) - headers: Optional HTTP headers dict - auth: Optional authentication - httpx_client_factory: Optional custom HTTPX client factory</p> <code>{}</code> <p>Returns:</p> Type Description <code>FastMCP</code> <p>FastMCP proxy server instance</p> Example <p>server = create_proxy_server( ...     url=\"http://pod.default.svc.cluster.local:8080/sse\", ...     sse_read_timeout=600.0 ... )</p> Source code in <code>src/mcp_ephemeral_k8s/k8s/job.py</code> <pre><code>def create_proxy_server(url: str, **kwargs: Any) -&gt; FastMCP:\n    \"\"\"Create a proxy server from a remote MCP server over SSE.\n\n    Args:\n        url: The SSE endpoint URL of the remote MCP server\n        **kwargs: Additional keyword arguments for SSETransport configuration\n            - sse_read_timeout: SSE read timeout (default: 300s)\n            - headers: Optional HTTP headers dict\n            - auth: Optional authentication\n            - httpx_client_factory: Optional custom HTTPX client factory\n\n    Returns:\n        FastMCP proxy server instance\n\n    Example:\n        &gt;&gt;&gt; server = create_proxy_server(\n        ...     url=\"http://pod.default.svc.cluster.local:8080/sse\",\n        ...     sse_read_timeout=600.0\n        ... )\n    \"\"\"\n    # Only pass valid SSETransport parameters\n    valid_params = {\"sse_read_timeout\", \"headers\", \"auth\", \"httpx_client_factory\"}\n    transport_kwargs = {k: v for k, v in kwargs.items() if k in valid_params}\n\n    logger.debug(f\"Creating proxy server for {url} with kwargs: {transport_kwargs}\")\n\n    remote_client = Client(SSETransport(url=url, **transport_kwargs))\n    return FastMCP.as_proxy(remote_client)\n</code></pre>"},{"location":"modules/#mcp_ephemeral_k8s.k8s.job.delete_mcp_server_job","title":"<code>delete_mcp_server_job(core_v1, batch_v1, job_name, namespace)</code>","text":"<p>Delete a Kubernetes job and its associated pods.</p> <p>Parameters:</p> Name Type Description Default <code>core_v1</code> <code>CoreV1Api</code> <p>The Kubernetes core API client</p> required <code>batch_v1</code> <code>BatchV1Api</code> <p>The Kubernetes batch API client</p> required <code>job_name</code> <code>str</code> <p>The name of the pod to delete</p> required <code>namespace</code> <code>str</code> <p>The namespace of the pod</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the job was deleted successfully, False otherwise</p> Source code in <code>src/mcp_ephemeral_k8s/k8s/job.py</code> <pre><code>def delete_mcp_server_job(\n    core_v1: client.CoreV1Api, batch_v1: client.BatchV1Api, job_name: str, namespace: str\n) -&gt; bool:\n    \"\"\"\n    Delete a Kubernetes job and its associated pods.\n\n    Args:\n        core_v1: The Kubernetes core API client\n        batch_v1: The Kubernetes batch API client\n        job_name: The name of the pod to delete\n        namespace: The namespace of the pod\n\n    Returns:\n        True if the job was deleted successfully, False otherwise\n    \"\"\"\n    try:\n        pods = core_v1.list_namespaced_pod(namespace=namespace, label_selector=f\"app={job_name}\")\n        for pod in pods.items:\n            if pod.metadata is None:\n                continue\n            pod_name_to_delete = pod.metadata.name\n            if pod_name_to_delete is None:\n                continue\n            logger.info(f\"Deleting pod {pod_name_to_delete}\")\n            core_v1.delete_namespaced_pod(\n                name=pod_name_to_delete,\n                namespace=namespace,\n                body=client.V1DeleteOptions(grace_period_seconds=0, propagation_policy=\"Background\"),\n            )\n    except ApiException:\n        logger.exception(\"Error deleting pods\")\n        return False\n    try:\n        batch_v1.delete_namespaced_job(\n            name=job_name, namespace=namespace, body=client.V1DeleteOptions(propagation_policy=\"Foreground\")\n        )\n        logger.info(f\"Job '{job_name}' deleted successfully\")\n    except ApiException:\n        logger.exception(\"Error deleting job\")\n        return False\n    else:\n        return True\n</code></pre>"},{"location":"modules/#mcp_ephemeral_k8s.k8s.job.expose_mcp_server_port","title":"<code>expose_mcp_server_port(core_v1, job_name, namespace, port)</code>","text":"<p>Expose the MCP server port to the outside world.</p> <p>Parameters:</p> Name Type Description Default <code>core_v1</code> <code>CoreV1Api</code> <p>The Kubernetes core API client</p> required <code>job_name</code> <code>str</code> <p>Name of the pod (job name)</p> required <code>namespace</code> <code>str</code> <p>Kubernetes namespace</p> required <code>port</code> <code>int</code> <p>Port to expose</p> required Source code in <code>src/mcp_ephemeral_k8s/k8s/job.py</code> <pre><code>def expose_mcp_server_port(core_v1: client.CoreV1Api, job_name: str, namespace: str, port: int) -&gt; None:\n    \"\"\"\n    Expose the MCP server port to the outside world.\n\n    Args:\n        core_v1: The Kubernetes core API client\n        job_name: Name of the pod (job name)\n        namespace: Kubernetes namespace\n        port: Port to expose\n    \"\"\"\n    core_v1.create_namespaced_service(\n        namespace=namespace,\n        body=client.V1Service(\n            metadata=client.V1ObjectMeta(name=job_name),\n            spec=client.V1ServiceSpec(\n                selector={\"job-name\": job_name},\n                ports=[client.V1ServicePort(port=port)],\n            ),\n        ),\n    )\n    logger.info(f\"Service '{job_name}' created successfully\")\n</code></pre>"},{"location":"modules/#mcp_ephemeral_k8s.k8s.job.get_mcp_server_job_status","title":"<code>get_mcp_server_job_status(batch_v1, job_name, namespace)</code>","text":"<p>Get the status of a Kubernetes job.</p> <p>Parameters:</p> Name Type Description Default <code>batch_v1</code> <code>BatchV1Api</code> <p>The Kubernetes batch API client</p> required <code>job_name</code> <code>str</code> <p>The name of the pod to get the status of</p> required <code>namespace</code> <code>str</code> <p>The namespace of the pod</p> required <p>Returns:</p> Type Description <code>None | V1Job</code> <p>The status of the job</p> Source code in <code>src/mcp_ephemeral_k8s/k8s/job.py</code> <pre><code>def get_mcp_server_job_status(batch_v1: client.BatchV1Api, job_name: str, namespace: str) -&gt; None | client.V1Job:\n    \"\"\"\n    Get the status of a Kubernetes job.\n\n    Args:\n        batch_v1: The Kubernetes batch API client\n        job_name: The name of the pod to get the status of\n        namespace: The namespace of the pod\n\n    Returns:\n        The status of the job\n    \"\"\"\n    try:\n        job = cast(client.V1Job, batch_v1.read_namespaced_job(name=job_name, namespace=namespace))\n\n        # Get status\n        if job.status is not None:\n            active = job.status.active if job.status.active is not None else 0\n            succeeded = job.status.succeeded if job.status.succeeded is not None else 0\n            failed = job.status.failed if job.status.failed is not None else 0\n\n            logger.info(f\"Job '{job_name}' status:\")\n            logger.info(f\"Active pods: {active}\")\n            logger.info(f\"Succeeded pods: {succeeded}\")\n            logger.info(f\"Failed pods: {failed}\")\n\n        # Get job creation time\n        if job.metadata is not None and job.metadata.creation_timestamp is not None:\n            creation_time = job.metadata.creation_timestamp\n            logger.info(f\"Creation time: {creation_time}\")\n    except ApiException as e:\n        if e.status == 404:\n            logger.info(f\"Job '{job_name}' not found\")\n        else:\n            logger.info(f\"Error getting job status: {e}\")\n        return None\n    else:\n        return job\n</code></pre>"},{"location":"modules/#mcp_ephemeral_k8s.k8s.job.remove_mcp_server_port","title":"<code>remove_mcp_server_port(core_v1, job_name, namespace)</code>","text":"<p>Remove the MCP server port from the outside world.</p> <p>Parameters:</p> Name Type Description Default <code>core_v1</code> <code>CoreV1Api</code> <p>The Kubernetes core API client</p> required <code>job_name</code> <code>str</code> <p>Name of the pod</p> required <code>namespace</code> <code>str</code> <p>Kubernetes namespace</p> required Source code in <code>src/mcp_ephemeral_k8s/k8s/job.py</code> <pre><code>def remove_mcp_server_port(core_v1: client.CoreV1Api, job_name: str, namespace: str) -&gt; None:\n    \"\"\"\n    Remove the MCP server port from the outside world.\n\n    Args:\n        core_v1: The Kubernetes core API client\n        job_name: Name of the pod\n        namespace: Kubernetes namespace\n    \"\"\"\n    core_v1.delete_namespaced_service(name=job_name, namespace=namespace)\n    logger.info(f\"Service '{job_name}' deleted successfully\")\n</code></pre>"},{"location":"modules/#mcp_ephemeral_k8s.k8s.job.wait_for_job_deletion","title":"<code>wait_for_job_deletion(batch_v1, job_name, namespace, sleep_time=1, max_wait_time=60)</code>  <code>async</code>","text":"<p>Wait for a job to be deleted.</p> <p>Parameters:</p> Name Type Description Default <code>batch_v1</code> <code>BatchV1Api</code> <p>The Kubernetes batch API client</p> required <code>job_name</code> <code>str</code> <p>Name of the pod</p> required <code>namespace</code> <code>str</code> <p>Kubernetes namespace</p> required <code>sleep_time</code> <code>float</code> <p>Time to sleep between checks</p> <code>1</code> <code>max_wait_time</code> <code>float</code> <p>Maximum time to wait before timing out</p> <code>60</code> <p>Raises:</p> Type Description <code>MCPJobTimeoutError</code> <p>If the job is not deleted within max_wait_time</p> Source code in <code>src/mcp_ephemeral_k8s/k8s/job.py</code> <pre><code>async def wait_for_job_deletion(\n    batch_v1: client.BatchV1Api, job_name: str, namespace: str, sleep_time: float = 1, max_wait_time: float = 60\n) -&gt; None:\n    \"\"\"\n    Wait for a job to be deleted.\n\n    Args:\n        batch_v1: The Kubernetes batch API client\n        job_name: Name of the pod\n        namespace: Kubernetes namespace\n        sleep_time: Time to sleep between checks\n        max_wait_time: Maximum time to wait before timing out\n\n    Raises:\n        MCPJobTimeoutError: If the job is not deleted within max_wait_time\n    \"\"\"\n    start_time = time.time()\n    while True:\n        if time.time() - start_time &gt; max_wait_time:\n            raise MCPJobTimeoutError(namespace, job_name)\n        if get_mcp_server_job_status(batch_v1, job_name, namespace) is None:\n            break\n        await asyncio.sleep(sleep_time)\n</code></pre>"},{"location":"modules/#mcp_ephemeral_k8s.k8s.job.wait_for_job_ready","title":"<code>wait_for_job_ready(batch_v1, core_v1, job_name, namespace, sleep_time=1, max_wait_time=60)</code>  <code>async</code>","text":"<p>Wait for a job's pod to be in the running state and ready (probes successful).</p> <p>Parameters:</p> Name Type Description Default <code>batch_v1</code> <code>BatchV1Api</code> <p>The Kubernetes batch API client</p> required <code>core_v1</code> <code>CoreV1Api</code> <p>The Kubernetes core API client</p> required <code>job_name</code> <code>str</code> <p>Name of the pod</p> required <code>namespace</code> <code>str</code> <p>Kubernetes namespace</p> required <code>sleep_time</code> <code>float</code> <p>Time to sleep between checks</p> <code>1</code> <code>max_wait_time</code> <code>float</code> <p>Maximum time to wait before timing out</p> <code>60</code> <p>Raises:</p> Type Description <code>MCPJobTimeoutError</code> <p>If the job does not become ready within max_wait_time</p> Source code in <code>src/mcp_ephemeral_k8s/k8s/job.py</code> <pre><code>async def wait_for_job_ready(\n    batch_v1: client.BatchV1Api,\n    core_v1: client.CoreV1Api,\n    job_name: str,\n    namespace: str,\n    sleep_time: float = 1,\n    max_wait_time: float = 60,\n) -&gt; None:\n    \"\"\"\n    Wait for a job's pod to be in the running state and ready (probes successful).\n\n    Args:\n        batch_v1: The Kubernetes batch API client\n        core_v1: The Kubernetes core API client\n        job_name: Name of the pod\n        namespace: Kubernetes namespace\n        sleep_time: Time to sleep between checks\n        max_wait_time: Maximum time to wait before timing out\n\n    Raises:\n        MCPJobTimeoutError: If the job does not become ready within max_wait_time\n    \"\"\"\n    start_time = time.time()\n    while True:\n        if time.time() - start_time &gt; max_wait_time:\n            raise MCPJobTimeoutError(namespace, job_name)\n\n        job = get_mcp_server_job_status(batch_v1, job_name, namespace)\n        if job is None:\n            logger.warning(f\"Job '{job_name}' not found, waiting for pod to become ready...\")\n            await asyncio.sleep(sleep_time)\n            continue\n\n        if job.status is None:\n            logger.warning(f\"Job '{job_name}' status is None, waiting for pod to become ready...\")\n            await asyncio.sleep(sleep_time)\n            continue\n\n        # Check if any pod is in running state and ready\n        if check_pod_status(core_v1, job_name, namespace):\n            break\n\n        if job.status.active == 1:\n            logger.info(f\"Job '{job_name}' active\")\n        else:\n            logger.warning(f\"Job '{job_name}' in unknown state, waiting...\")\n\n        await asyncio.sleep(sleep_time)\n</code></pre>"},{"location":"modules/#rbac-management","title":"RBAC Management","text":"<p>Helper functions for managing RBAC resources for spawned MCP server pods.</p>"},{"location":"modules/#mcp_ephemeral_k8s.k8s.rbac.RBACPreset","title":"<code>RBACPreset</code>","text":"<p>               Bases: <code>StrEnum</code></p> <p>Preset RBAC configurations for service accounts.</p> Source code in <code>src/mcp_ephemeral_k8s/k8s/rbac.py</code> <pre><code>class RBACPreset(StrEnum):\n    \"\"\"Preset RBAC configurations for service accounts.\"\"\"\n\n    MINIMAL = \"minimal\"\n    EXTENSIVE = \"extensive\"\n</code></pre>"},{"location":"modules/#mcp_ephemeral_k8s.k8s.rbac.ServiceAccountConfig","title":"<code>ServiceAccountConfig</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Configuration for ServiceAccount RBAC permissions.</p> Source code in <code>src/mcp_ephemeral_k8s/k8s/rbac.py</code> <pre><code>class ServiceAccountConfig(BaseModel):\n    \"\"\"Configuration for ServiceAccount RBAC permissions.\"\"\"\n\n    preset: RBACPreset = Field(\n        default=RBACPreset.MINIMAL,\n        description=\"The RBAC preset to use for the service account\",\n    )\n    cluster_wide: bool = Field(\n        default=True,\n        description=\"Whether to create ClusterRole/ClusterRoleBinding (True) or Role/RoleBinding (False)\",\n    )\n</code></pre>"},{"location":"modules/#mcp_ephemeral_k8s.k8s.rbac.UnknownRBACPresetError","title":"<code>UnknownRBACPresetError</code>","text":"<p>               Bases: <code>ValueError</code></p> <p>Exception raised when an unknown RBAC preset is encountered.</p> Source code in <code>src/mcp_ephemeral_k8s/k8s/rbac.py</code> <pre><code>class UnknownRBACPresetError(ValueError):\n    \"\"\"Exception raised when an unknown RBAC preset is encountered.\"\"\"\n\n    def __init__(self, preset: RBACPreset) -&gt; None:\n        self.preset = preset\n        super().__init__(f\"Unknown RBAC preset: {preset}\")\n</code></pre>"},{"location":"modules/#mcp_ephemeral_k8s.k8s.rbac.create_service_account_for_job","title":"<code>create_service_account_for_job(core_v1, rbac_v1, job_name, namespace, cluster_wide=True, sa_config=None)</code>","text":"<p>Create a ServiceAccount and RBAC resources for a spawned MCP server job.</p> <p>This creates: - A ServiceAccount - A Role/ClusterRole with permissions based on the ServiceAccountConfig - A RoleBinding/ClusterRoleBinding</p> <p>Parameters:</p> Name Type Description Default <code>core_v1</code> <code>CoreV1Api</code> <p>The Kubernetes core API client</p> required <code>rbac_v1</code> <code>RbacAuthorizationV1Api</code> <p>The Kubernetes RBAC API client</p> required <code>job_name</code> <code>str</code> <p>The name of the job (used for naming resources)</p> required <code>namespace</code> <code>str</code> <p>Kubernetes namespace</p> required <code>cluster_wide</code> <code>bool</code> <p>Whether to create ClusterRole/ClusterRoleBinding (default: True)          Note: This parameter is deprecated when sa_config is provided</p> <code>True</code> <code>sa_config</code> <code>ServiceAccountConfig | None</code> <p>ServiceAccount configuration with RBAC preset (default: minimal preset)</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>The name of the created ServiceAccount</p> Source code in <code>src/mcp_ephemeral_k8s/k8s/rbac.py</code> <pre><code>def create_service_account_for_job(\n    core_v1: client.CoreV1Api,\n    rbac_v1: client.RbacAuthorizationV1Api,\n    job_name: str,\n    namespace: str,\n    cluster_wide: bool = True,\n    sa_config: ServiceAccountConfig | None = None,\n) -&gt; str:\n    \"\"\"\n    Create a ServiceAccount and RBAC resources for a spawned MCP server job.\n\n    This creates:\n    - A ServiceAccount\n    - A Role/ClusterRole with permissions based on the ServiceAccountConfig\n    - A RoleBinding/ClusterRoleBinding\n\n    Args:\n        core_v1: The Kubernetes core API client\n        rbac_v1: The Kubernetes RBAC API client\n        job_name: The name of the job (used for naming resources)\n        namespace: Kubernetes namespace\n        cluster_wide: Whether to create ClusterRole/ClusterRoleBinding (default: True)\n                     Note: This parameter is deprecated when sa_config is provided\n        sa_config: ServiceAccount configuration with RBAC preset (default: minimal preset)\n\n    Returns:\n        The name of the created ServiceAccount\n    \"\"\"\n    service_account_name = f\"{job_name}-sa\"\n\n    # Create ServiceAccount\n    _create_service_account(core_v1, service_account_name, namespace, job_name)\n\n    # Use ServiceAccountConfig if provided, otherwise use defaults\n    if sa_config is None:\n        sa_config = ServiceAccountConfig()\n\n    rules = _get_rbac_rules_by_preset(sa_config.preset)\n\n    # Create Role/ClusterRole and RoleBinding/ClusterRoleBinding\n    if sa_config.cluster_wide:\n        _create_cluster_role_and_binding(rbac_v1, job_name, namespace, service_account_name, rules)\n    else:\n        _create_role_and_binding(rbac_v1, job_name, namespace, service_account_name, rules)\n\n    return service_account_name\n</code></pre>"},{"location":"modules/#mcp_ephemeral_k8s.k8s.rbac.delete_service_account_for_job","title":"<code>delete_service_account_for_job(core_v1, rbac_v1, job_name, namespace, cluster_wide=True)</code>","text":"<p>Delete the ServiceAccount and RBAC resources for a spawned MCP server job.</p> <p>Parameters:</p> Name Type Description Default <code>core_v1</code> <code>CoreV1Api</code> <p>The Kubernetes core API client</p> required <code>rbac_v1</code> <code>RbacAuthorizationV1Api</code> <p>The Kubernetes RBAC API client</p> required <code>job_name</code> <code>str</code> <p>The name of the job</p> required <code>namespace</code> <code>str</code> <p>Kubernetes namespace</p> required <code>cluster_wide</code> <code>bool</code> <p>Whether ClusterRole/ClusterRoleBinding were created (default: True)</p> <code>True</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if all resources were deleted successfully, False otherwise</p> Source code in <code>src/mcp_ephemeral_k8s/k8s/rbac.py</code> <pre><code>def delete_service_account_for_job(\n    core_v1: client.CoreV1Api,\n    rbac_v1: client.RbacAuthorizationV1Api,\n    job_name: str,\n    namespace: str,\n    cluster_wide: bool = True,\n) -&gt; bool:\n    \"\"\"\n    Delete the ServiceAccount and RBAC resources for a spawned MCP server job.\n\n    Args:\n        core_v1: The Kubernetes core API client\n        rbac_v1: The Kubernetes RBAC API client\n        job_name: The name of the job\n        namespace: Kubernetes namespace\n        cluster_wide: Whether ClusterRole/ClusterRoleBinding were created (default: True)\n\n    Returns:\n        True if all resources were deleted successfully, False otherwise\n    \"\"\"\n    service_account_name = f\"{job_name}-sa\"\n\n    # Delete Role/ClusterRole and RoleBinding/ClusterRoleBinding\n    if cluster_wide:\n        rbac_success = _delete_cluster_role_and_binding(rbac_v1, job_name)\n    else:\n        rbac_success = _delete_role_and_binding(rbac_v1, job_name, namespace)\n\n    # Delete ServiceAccount\n    sa_success = _delete_service_account(core_v1, service_account_name, namespace)\n\n    return rbac_success and sa_success\n</code></pre>"},{"location":"modules/#utilities","title":"Utilities","text":"<p>This module contains a utility function to generate unique identifiers for MCP ephemeral K8s resources based on RFC 1123 Label Names.</p>"},{"location":"modules/#mcp_ephemeral_k8s.k8s.uid.generate_unique_id","title":"<code>generate_unique_id(prefix=None, max_length=63)</code>","text":"<p>Generate a unique identifier that follows the Kubernetes naming rules (RFC 1123 Label Names).</p> <p>RFC 1123 Label Names must: - Contain only lowercase alphanumeric characters or '-' - Start with an alphanumeric character - End with an alphanumeric character - Be at most 63 characters</p> <p>Parameters:</p> Name Type Description Default <code>prefix</code> <code>str | None</code> <p>Optional prefix for the ID. Will be converted to lowercase and non-compliant     characters will be replaced with dashes.</p> <code>None</code> <code>max_length</code> <code>int</code> <p>Maximum length of the generated ID, defaults to 63 (K8s limit).</p> <code>63</code> <p>Returns:</p> Type Description <code>str</code> <p>A unique RFC 1123 compliant identifier string.</p> Source code in <code>src/mcp_ephemeral_k8s/k8s/uid.py</code> <pre><code>def generate_unique_id(prefix: str | None = None, max_length: int = 63) -&gt; str:\n    \"\"\"\n    Generate a unique identifier that follows the Kubernetes naming rules (RFC 1123 Label Names).\n\n    RFC 1123 Label Names must:\n    - Contain only lowercase alphanumeric characters or '-'\n    - Start with an alphanumeric character\n    - End with an alphanumeric character\n    - Be at most 63 characters\n\n    Args:\n        prefix: Optional prefix for the ID. Will be converted to lowercase and non-compliant\n                characters will be replaced with dashes.\n        max_length: Maximum length of the generated ID, defaults to 63 (K8s limit).\n\n    Returns:\n        A unique RFC 1123 compliant identifier string.\n    \"\"\"\n    # Process prefix if provided\n    processed_prefix = \"\"\n    if prefix:\n        # Convert to lowercase and replace invalid characters\n        processed_prefix = \"\".join(\n            c if c.isalnum() and c.islower() else (c.lower() if c.isalnum() else \"-\") for c in prefix\n        )\n\n        # Ensure prefix starts with alphanumeric\n        if processed_prefix and not processed_prefix[0].isalnum():\n            processed_prefix = f\"p{processed_prefix}\"\n\n        # Add separator\n        if processed_prefix:\n            processed_prefix = f\"{processed_prefix}-\"\n\n    # Generate a unique part (timestamp + random)\n    timestamp = str(int(time.time()))\n    random_chars = \"\".join(random.choices(string.ascii_lowercase + string.digits, k=8))  # noqa: S311\n    unique_part = f\"{timestamp}-{random_chars}\"\n\n    # Combine and ensure max length\n    full_id = f\"{processed_prefix}{unique_part}\"\n    if len(full_id) &gt; max_length:\n        # If too long, truncate the ID but keep the random part\n        chars_to_keep = max_length - len(random_chars) - 1\n        full_id = f\"{full_id[:chars_to_keep]}-{random_chars}\"\n\n    # Ensure ID ends with alphanumeric\n    if not full_id[-1].isalnum():\n        full_id = f\"{full_id[:-1]}{random.choice(string.ascii_lowercase)}\"  # noqa: S311\n\n    return full_id\n</code></pre>"},{"location":"modules/#integrations-presets","title":"Integrations &amp; Presets","text":""}]}